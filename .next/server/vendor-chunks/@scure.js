"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure";
exports.ids = ["vendor-chunks/@scure"];
exports.modules = {

/***/ "(ssr)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr)) return false;\n    if (arr.length === 0) return true;\n    if (isString) {\n        return arr.every((item)=>typeof item === \"string\");\n    } else {\n        return arr.every((item)=>Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== \"function\") throw new Error(\"function expected\");\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== \"string\") throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input)) throw new Error(\"array expected\");\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function chain(...args) {\n    const id = (a)=>a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b)=>(c)=>a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x)=>x.decode).reduce(wrap, id);\n    return {\n        encode,\n        decode\n    };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */ function alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === \"string\" ? letters.split(\"\") : letters;\n    const len = lettersA.length;\n    astrArr(\"alphabet\", lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i)=>[\n            l,\n            i\n        ]));\n    return {\n        encode: (digits)=>{\n            aArr(digits);\n            return digits.map((i)=>{\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input)=>{\n            aArr(input);\n            return input.map((letter)=>{\n                astr(\"alphabet.decode\", letter);\n                const i = indexes.get(letter);\n                if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function join(separator = \"\") {\n    astr(\"join\", separator);\n    return {\n        encode: (from)=>{\n            astrArr(\"join.decode\", from);\n            return from.join(separator);\n        },\n        decode: (to)=>{\n            astr(\"join.decode\", to);\n            return to.split(separator);\n        }\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */ function padding(bits, chr = \"=\") {\n    anumber(bits);\n    astr(\"padding\", chr);\n    return {\n        encode (data) {\n            astrArr(\"padding.encode\", data);\n            while(data.length * bits % 8)data.push(chr);\n            return data;\n        },\n        decode (input) {\n            astrArr(\"padding.decode\", input);\n            let end = input.length;\n            if (end * bits % 8) throw new Error(\"padding: invalid, string should have whole number of bytes\");\n            for(; end > 0 && input[end - 1] === chr; end--){\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0) throw new Error(\"padding: invalid, string has too much padding\");\n            }\n            return input.slice(0, end);\n        }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function normalize(fn) {\n    afn(fn);\n    return {\n        encode: (from)=>from,\n        decode: (to)=>fn(to)\n    };\n}\n/**\n * Slow: O(n^2) time complexity\n */ function convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length) return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d)=>{\n        anumber(d);\n        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while(true){\n        let carry = 0;\n        let done = true;\n        for(let i = pos; i < dlen; i++){\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {\n                throw new Error(\"convertRadix: carry overflow\");\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error(\"convertRadix: carry overflow\");\n            if (!done) continue;\n            else if (!rounded) pos = i;\n            else done = false;\n        }\n        res.push(carry);\n        if (done) break;\n    }\n    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b)=>b === 0 ? a : gcd(b, a % b);\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (()=>{\n    let res = [];\n    for(let i = 0; i < 40; i++)res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */ function convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data){\n        anumber(n);\n        if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = carry << from | n;\n        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined) throw new Error(\"invalid carry\");\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = carry << to - pos & mask;\n    if (!padding && pos >= from) throw new Error(\"Excess padding\");\n    if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0) res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix.encode input should be Uint8Array\");\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits)=>{\n            anumArr(\"radix.decode\", digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        }\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */ function radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32) throw new Error(\"radix2: bits should be in (0..32]\");\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error(\"radix2: carry overflow\");\n    return {\n        encode: (bytes)=>{\n            if (!isBytes(bytes)) throw new Error(\"radix2.encode input should be Uint8Array\");\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits)=>{\n            anumArr(\"radix2.decode\", digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        }\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function(...args) {\n        try {\n            return fn.apply(null, args);\n        } catch (e) {}\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.encode: input should be Uint8Array\");\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode (data) {\n            if (!isBytes(data)) throw new Error(\"checksum.decode: input should be Uint8Array\");\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error(\"Invalid checksum\");\n            return payload;\n        }\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet,\n    chain,\n    checksum,\n    convertRadix,\n    convertRadix2,\n    radix,\n    radix2,\n    join,\n    padding\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */ const base16 = chain(radix2(4), alphabet(\"0123456789ABCDEF\"), join(\"\"));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32 = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), padding(5), join(\"\"));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32nopad = chain(radix2(5), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), join(\"\"));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32hex = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), padding(5), join(\"\"));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32hexnopad = chain(radix2(5), alphabet(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), join(\"\"));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base32crockford = chain(radix2(5), alphabet(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), join(\"\"), normalize((s)=>s.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\")));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toBase64 === \"function\" && typeof Uint8Array.fromBase64 === \"function\")();\nconst decodeBase64Builtin = (s, isUrl)=>{\n    astr(\"base64\", s);\n    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n    const alphabet = isUrl ? \"base64url\" : \"base64\";\n    if (s.length > 0 && !re.test(s)) throw new Error(\"invalid base64\");\n    return Uint8Array.fromBase64(s, {\n        alphabet,\n        lastChunkHandling: \"strict\"\n    });\n};\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ // prettier-ignore\nconst base64 = hasBase64Builtin ? {\n    encode (b) {\n        abytes(b);\n        return b.toBase64();\n    },\n    decode (s) {\n        return decodeBase64Builtin(s, false);\n    }\n} : chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), padding(6), join(\"\"));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base64nopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), join(\"\"));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ // prettier-ignore\nconst base64url = hasBase64Builtin ? {\n    encode (b) {\n        abytes(b);\n        return b.toBase64({\n            alphabet: \"base64url\"\n        });\n    },\n    decode (s) {\n        return decodeBase64Builtin(s, true);\n    }\n} : chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), padding(6), join(\"\"));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */ const base64urlnopad = chain(radix2(6), alphabet(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), join(\"\"));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc)=>chain(radix(58), alphabet(abc), join(\"\"));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */ const base58 = genBase58(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n/**\n * base58: flickr version. Check out `base58`.\n */ const base58flickr = genBase58(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\");\n/**\n * base58: XRP version. Check out `base58`.\n */ const base58xrp = genBase58(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\");\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [\n    0,\n    2,\n    3,\n    5,\n    6,\n    7,\n    9,\n    10,\n    11\n];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */ const base58xmr = {\n    encode (data) {\n        let res = \"\";\n        for(let i = 0; i < data.length; i += 8){\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], \"1\");\n        }\n        return res;\n    },\n    decode (str) {\n        let res = [];\n        for(let i = 0; i < str.length; i += 11){\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for(let j = 0; j < block.length - blockLen; j++){\n                if (block[j] !== 0) throw new Error(\"base58xmr: wrong padding\");\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    }\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */ const createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */ const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), join(\"\"));\nconst POLYMOD_GENERATORS = [\n    0x3b6a57b2,\n    0x26508e6d,\n    0x1ea119fa,\n    0x3d4233dd,\n    0x2a1462b3\n];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){\n        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for(let i = 0; i < len; i++){\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ c >> 5;\n    }\n    chk = bech32Polymod(chk);\n    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;\n    for (let v of words)chk = bech32Polymod(chk) ^ v;\n    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([\n        chk % powers[30]\n    ], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */ function genBech32(encoding) {\n    const ENCODING_CONST = encoding === \"bech32\" ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr(\"bech32.encode prefix\", prefix);\n        if (isBytes(words)) words = Array.from(words);\n        anumArr(\"bech32.encode\", words);\n        const plen = prefix.length;\n        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr(\"bech32.decode input\", str);\n        const slen = str.length;\n        if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf(\"1\");\n        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6) throw new Error(\"Data must be at least 6 characters long\");\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return {\n            prefix,\n            words\n        };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return {\n            prefix,\n            words,\n            bytes: fromWords(words)\n        };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */ const bech32 = genBech32(\"bech32\");\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */ const bech32m = genBech32(\"bech32m\");\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */ const utf8 = {\n    encode: (data)=>new TextDecoder().decode(data),\n    decode: (str)=>new TextEncoder().encode(str)\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\n// prettier-ignore\nconst hexBuiltin = {\n    encode (data) {\n        abytes(data);\n        return data.toHex();\n    },\n    decode (s) {\n        astr(\"hex\", s);\n        return Uint8Array.fromHex(s);\n    }\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */ const hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet(\"0123456789abcdef\"), join(\"\"), normalize((s)=>{\n    if (typeof s !== \"string\" || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8,\n    hex,\n    base16,\n    base32,\n    base64,\n    base64url,\n    base58,\n    base58xmr\n};\nconst coderTypeError = \"Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr\";\n/** @deprecated */ const bytesToString = (type, bytes)=>{\n    if (typeof type !== \"string\" || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (!isBytes(bytes)) throw new TypeError(\"bytesToString() expects Uint8Array\");\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */ const str = bytesToString; // as in python, but for bytes only\n/** @deprecated */ const stringToBytes = (type, str)=>{\n    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n    if (typeof str !== \"string\") throw new TypeError(\"stringToBytes() expects string\");\n    return CODERS[type].decode(str);\n};\n/** @deprecated */ const bytes = stringToBytes; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0VBQWtFLEdBQ2xFLFNBQVNBLFFBQVFDLENBQUM7SUFDZCxPQUFPQSxhQUFhQyxjQUFlQyxZQUFZQyxNQUFNLENBQUNILE1BQU1BLEVBQUVJLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3ZGO0FBQ0EscUNBQXFDLEdBQ3JDLFNBQVNDLE9BQU9DLENBQUMsRUFBRSxHQUFHQyxPQUFPO0lBQ3pCLElBQUksQ0FBQ1QsUUFBUVEsSUFDVCxNQUFNLElBQUlFLE1BQU07SUFDcEIsSUFBSUQsUUFBUUUsTUFBTSxHQUFHLEtBQUssQ0FBQ0YsUUFBUUcsUUFBUSxDQUFDSixFQUFFRyxNQUFNLEdBQ2hELE1BQU0sSUFBSUQsTUFBTSxtQ0FBbUNELFVBQVUsa0JBQWtCRCxFQUFFRyxNQUFNO0FBQy9GO0FBQ0EsU0FBU0UsVUFBVUMsUUFBUSxFQUFFQyxHQUFHO0lBQzVCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixNQUNmLE9BQU87SUFDWCxJQUFJQSxJQUFJSixNQUFNLEtBQUssR0FDZixPQUFPO0lBQ1gsSUFBSUcsVUFBVTtRQUNWLE9BQU9DLElBQUlHLEtBQUssQ0FBQyxDQUFDQyxPQUFTLE9BQU9BLFNBQVM7SUFDL0MsT0FDSztRQUNELE9BQU9KLElBQUlHLEtBQUssQ0FBQyxDQUFDQyxPQUFTQyxPQUFPQyxhQUFhLENBQUNGO0lBQ3BEO0FBQ0o7QUFDQSwrQ0FBK0M7QUFDL0MsU0FBU0csSUFBSUMsS0FBSztJQUNkLElBQUksT0FBT0EsVUFBVSxZQUNqQixNQUFNLElBQUliLE1BQU07SUFDcEIsT0FBTztBQUNYO0FBQ0EsU0FBU2MsS0FBS0MsS0FBSyxFQUFFRixLQUFLO0lBQ3RCLElBQUksT0FBT0EsVUFBVSxVQUNqQixNQUFNLElBQUliLE1BQU0sQ0FBQyxFQUFFZSxNQUFNLGlCQUFpQixD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O0lBQVFDO0lBQVFnQjtJQUFRRTtJQUFXSTtJQUFRSTtBQUMxRDtBQUNBLE1BQU1zRCxpQkFBaUI7QUFDdkIsZ0JBQWdCLEdBQ1QsTUFBTUMsZ0JBQWdCLENBQUNDLE1BQU1oRztJQUNoQyxJQUFJLE9BQU9nRyxTQUFTLFlBQVksQ0FBQ0gsT0FBT0ksY0FBYyxDQUFDRCxPQUNuRCxNQUFNLElBQUl4QixVQUFVc0I7SUFDeEIsSUFBSSxDQUFDN0wsUUFBUStGLFFBQ1QsTUFBTSxJQUFJd0UsVUFBVTtJQUN4QixPQUFPcUIsTUFBTSxDQUFDRyxLQUFLLENBQUMzSixNQUFNLENBQUMyRDtBQUMvQixFQUFFO0FBQ0YsZ0JBQWdCLEdBQ1QsTUFBTTRDLE1BQU1tRCxjQUFjLENBQUMsbUNBQW1DO0FBQ3JFLGdCQUFnQixHQUNULE1BQU1HLGdCQUFnQixDQUFDRixNQUFNcEQ7SUFDaEMsSUFBSSxDQUFDaUQsT0FBT0ksY0FBYyxDQUFDRCxPQUN2QixNQUFNLElBQUl4QixVQUFVc0I7SUFDeEIsSUFBSSxPQUFPbEQsUUFBUSxVQUNmLE1BQU0sSUFBSTRCLFVBQVU7SUFDeEIsT0FBT3FCLE1BQU0sQ0FBQ0csS0FBSyxDQUFDdkosTUFBTSxDQUFDbUc7QUFDL0IsRUFBRTtBQUNGLGdCQUFnQixHQUNULE1BQU01QyxRQUFRa0csY0FBYyxDQUNuQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub2NvZGUtbG1zLWJ1aWxkZXIvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcz9lNzkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmZ1bmN0aW9uIGFieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAnICsgbGVuZ3RocyArICcsIGdvdCBsZW5ndGg9JyArIGIubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlPZihpc1N0cmluZywgYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnIuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJyLmV2ZXJ5KChpdGVtKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSk7XG4gICAgfVxufVxuLy8gbm8gYWJ5dGVzOiBzZWVtcyB0byBoYXZlIDEwJSBzbG93ZG93bi4gV2h5PyFcbmZ1bmN0aW9uIGFmbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzdHIobGFiZWwsIGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH06IHN0cmluZyBleHBlY3RlZGApO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGFBcnIoaW5wdXQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBhc3RyQXJyKGxhYmVsLCBpbnB1dCkge1xuICAgIGlmICghaXNBcnJheU9mKHRydWUsIGlucHV0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2xhYmVsfTogYXJyYXkgb2Ygc3RyaW5ncyBleHBlY3RlZGApO1xufVxuZnVuY3Rpb24gYW51bUFycihsYWJlbCwgaW5wdXQpIHtcbiAgICBpZiAoIWlzQXJyYXlPZihmYWxzZSwgaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9OiBhcnJheSBvZiBudW1iZXJzIGV4cGVjdGVkYCk7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBpZCA9IChhKSA9PiBhO1xuICAgIC8vIFdyYXAgY2FsbCBpbiBjbG9zdXJlIHNvIEpJVCBjYW4gaW5saW5lIGNhbGxzXG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1stMV0uZW5jb2RlKGFyZ3NbLTJdLmVuY29kZShbLi4uXSkpXG4gICAgY29uc3QgZW5jb2RlID0gYXJncy5tYXAoKHgpID0+IHguZW5jb2RlKS5yZWR1Y2VSaWdodCh3cmFwLCBpZCk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbMF0uZGVjb2RlKGFyZ3NbMV0uZGVjb2RlKC4uLikpXG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5tYXAoKHgpID0+IHguZGVjb2RlKS5yZWR1Y2Uod3JhcCwgaWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG4vKipcbiAqIEVuY29kZXMgaW50ZWdlciByYWRpeCByZXByZXNlbnRhdGlvbiB0byBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGFscGhhYmV0IGFuZCBiYWNrLlxuICogQ291bGQgYWxzbyBiZSBhcnJheSBvZiBzdHJpbmdzLlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQobGV0dGVycykge1xuICAgIC8vIG1hcHBpbmcgMSB0byBcImJcIlxuICAgIGNvbnN0IGxldHRlcnNBID0gdHlwZW9mIGxldHRlcnMgPT09ICdzdHJpbmcnID8gbGV0dGVycy5zcGxpdCgnJykgOiBsZXR0ZXJzO1xuICAgIGNvbnN0IGxlbiA9IGxldHRlcnNBLmxlbmd0aDtcbiAgICBhc3RyQXJyKCdhbHBoYWJldCcsIGxldHRlcnNBKTtcbiAgICAvLyBtYXBwaW5nIFwiYlwiIHRvIDFcbiAgICBjb25zdCBpbmRleGVzID0gbmV3IE1hcChsZXR0ZXJzQS5tYXAoKGwsIGkpID0+IFtsLCBpXSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgYUFycihkaWdpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGkpIHx8IGkgPCAwIHx8IGkgPj0gbGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmVuY29kZTogZGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldCBcIiR7aX1cIi4gQWxsb3dlZDogJHtsZXR0ZXJzfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBsZXR0ZXJzQVtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgYUFycihpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhc3RyKCdhbHBoYWJldC5kZWNvZGUnLCBsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBpbmRleGVzLmdldChsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7bGV0dGVyc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBhc3RyKCdqb2luJywgc2VwYXJhdG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBhc3RyQXJyKCdqb2luLmRlY29kZScsIGZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgYXN0cignam9pbi5kZWNvZGUnLCB0byk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYWQgc3RyaW5ncyBhcnJheSBzbyBpdCBoYXMgaW50ZWdlciBudW1iZXIgb2YgYml0c1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhbnVtYmVyKGJpdHMpO1xuICAgIGFzdHIoJ3BhZGRpbmcnLCBjaHIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBhc3RyQXJyKCdwYWRkaW5nLmVuY29kZScsIGRhdGEpO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGFzdHJBcnIoJ3BhZGRpbmcuZGVjb2RlJywgaW5wdXQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZzogaW52YWxpZCwgc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gZW5kIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlID0gbGFzdCAqIGJpdHM7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGUgJSA4ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmc6IGludmFsaWQsIHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgYWZuKGZuKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG4vKipcbiAqIFNsb3c6IE8obl4yKSB0aW1lIGNvbXBsZXhpdHlcbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgLy8gYmFzZSAxIGlzIGltcG9zc2libGVcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiBpbnZhbGlkIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogaW52YWxpZCB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBhQXJyKGRhdGEpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEsIChkKSA9PiB7XG4gICAgICAgIGFudW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW50ZWdlcjogJHtkfWApO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9KTtcbiAgICBjb25zdCBkbGVuID0gZGlnaXRzLmxlbmd0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZnJvbUNhcnJ5ID0gZnJvbSAqIGNhcnJ5O1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbUNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICBmcm9tQ2FycnkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tQ2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IGRpZ2l0QmFzZSAvIHRvO1xuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZsb29yKGRpdik7XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSByb3VuZGVkO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyb3VuZGVkKSB8fCByb3VuZGVkICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXJvdW5kZWQpXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gKGEsIGIpID0+IChiID09PSAwID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmNvbnN0IHBvd2VycyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDIgKiogaSk7XG4gICAgcmV0dXJuIHJlcztcbn0pKCk7XG4vKipcbiAqIEltcGxlbWVudGVkIHdpdGggbnVtYmVycywgYmVjYXVzZSBCaWdJbnQgaXMgNXggc2xvd2VyXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBhQXJyKGRhdGEpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwOyAvLyBiaXR3aXNlIHBvc2l0aW9uIGluIGN1cnJlbnQgZWxlbWVudFxuICAgIGNvbnN0IG1heCA9IHBvd2Vyc1tmcm9tXTtcbiAgICBjb25zdCBtYXNrID0gcG93ZXJzW3RvXSAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYW51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gbWF4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjb25zdCBwb3cgPSBwb3dlcnNbcG9zXTtcbiAgICAgICAgaWYgKHBvdyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNhcnJ5Jyk7XG4gICAgICAgIGNhcnJ5ICY9IHBvdyAtIDE7IC8vIGNsZWFuIGNhcnJ5LCBvdGhlcndpc2UgaXQgd2lsbCBjYXVzZSBvdmVyZmxvd1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5ID4gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhbnVtYmVyKG51bSk7XG4gICAgY29uc3QgXzI1NiA9IDIgKiogODtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgXzI1NiwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBhbnVtQXJyKCdyYWRpeC5kZWNvZGUnLCBkaWdpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIF8yNTYpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBJZiBib3RoIGJhc2VzIGFyZSBwb3dlciBvZiBzYW1lIG51bWJlciAobGlrZSBgMioqOCA8LT4gMioqNjRgKSxcbiAqIHRoZXJlIGlzIGEgbGluZWFyIGFsZ29yaXRobS4gRm9yIG5vdyB3ZSBoYXZlIGltcGxlbWVudGF0aW9uIGZvciBwb3dlci1vZi10d28gYmFzZXMgb25seS5cbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhbnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBhbnVtQXJyKCdyYWRpeDIuZGVjb2RlJywgZGlnaXRzKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGFmbihmbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYW51bWJlcihsZW4pO1xuICAgIGFmbihmbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgdXRpbHMgPSB7XG4gICAgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgY29udmVydFJhZGl4LCBjb252ZXJ0UmFkaXgyLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nLFxufTtcbi8vIFJGQyA0NjQ4IGFrYSBSRkMgMzU0OFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIGJhc2UxNiBlbmNvZGluZyBmcm9tIFJGQyA0NjQ4LlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMTYuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcxMkFCJ1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIEhhcyBwYWRkaW5nLlxuICogVXNlIGBiYXNlMzJub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBBbHNvIGNoZWNrIG91dCBgYmFzZTMyaGV4YCwgYGJhc2UzMmhleG5vcGFkYCwgYGJhc2UzMmNyb2NrZm9yZGAuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMi5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0NLVlE9PT09J1xuICogYmFzZTMyLmRlY29kZSgnQ0tWUT09PT0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIE5vIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2UzMmAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQWxzbyBjaGVjayBvdXQgYGJhc2UzMmhleGAsIGBiYXNlMzJoZXhub3BhZGAsIGBiYXNlMzJjcm9ja2ZvcmRgLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0NLVlEnXG4gKiBiYXNlMzJub3BhZC5kZWNvZGUoJ0NLVlEnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMm5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gUGFkZGVkLiBDb21wYXJlZCB0byBvcmRpbmFyeSBgYmFzZTMyYCwgc2xpZ2h0bHkgZGlmZmVyZW50IGFscGhhYmV0LlxuICogVXNlIGBiYXNlMzJoZXhub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2UzMmhleC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzJBTEc9PT09J1xuICogYmFzZTMyaGV4LmRlY29kZSgnMkFMRz09PT0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTMyIGVuY29kaW5nIGZyb20gUkZDIDQ2NDguIE5vIHBhZGRpbmcuIENvbXBhcmVkIHRvIG9yZGluYXJ5IGBiYXNlMzJgLCBzbGlnaHRseSBkaWZmZXJlbnQgYWxwaGFiZXQuXG4gKiBVc2UgYGJhc2UzMmhleGAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJoZXhub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJzJBTEcnXG4gKiBiYXNlMzJoZXhub3BhZC5kZWNvZGUoJzJBTEcnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleG5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlMzIgZW5jb2RpbmcgZnJvbSBSRkMgNDY0OC4gRG91ZyBDcm9ja2ZvcmQncyB2ZXJzaW9uLlxuICogaHR0cHM6Ly93d3cuY3JvY2tmb3JkLmNvbS9iYXNlMzIuaHRtbFxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlMzJjcm9ja2ZvcmQuZW5jb2RlKFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pKTtcbiAqIC8vID0+ICcyQU5HJ1xuICogYmFzZTMyY3JvY2tmb3JkLmRlY29kZSgnMkFORycpO1xuICogLy8gPT4gVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSlcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbi8vIEJ1aWx0LWluIGJhc2U2NCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9tYmFzZTY0XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGhhc0Jhc2U2NEJ1aWx0aW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvQmFzZTY0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCA9PT0gJ2Z1bmN0aW9uJykoKTtcbmNvbnN0IGRlY29kZUJhc2U2NEJ1aWx0aW4gPSAocywgaXNVcmwpID0+IHtcbiAgICBhc3RyKCdiYXNlNjQnLCBzKTtcbiAgICBjb25zdCByZSA9IGlzVXJsID8gL15bQS1aYS16MC05PV8tXSskLyA6IC9eW0EtWmEtejAtOT0rL10rJC87XG4gICAgY29uc3QgYWxwaGFiZXQgPSBpc1VybCA/ICdiYXNlNjR1cmwnIDogJ2Jhc2U2NCc7XG4gICAgaWYgKHMubGVuZ3RoID4gMCAmJiAhcmUudGVzdChzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGJhc2U2NCcpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb21CYXNlNjQocywgeyBhbHBoYWJldCwgbGFzdENodW5rSGFuZGxpbmc6ICdzdHJpY3QnIH0pO1xufTtcbi8qKlxuICogYmFzZTY0IGZyb20gUkZDIDQ2NDguIFBhZGRlZC5cbiAqIFVzZSBgYmFzZTY0bm9wYWRgIGZvciB1bnBhZGRlZCB2ZXJzaW9uLlxuICogQWxzbyBjaGVjayBvdXQgYGJhc2U2NHVybGAsIGBiYXNlNjR1cmxub3BhZGAuXG4gKiBGYWxscyBiYWNrIHRvIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTY0LmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzPSdcbiAqIGJhc2U2NC5kZWNvZGUoJ0Vxcz0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgYmFzZTY0ID0gaGFzQmFzZTY0QnVpbHRpbiA/IHtcbiAgICBlbmNvZGUoYikgeyBhYnl0ZXMoYik7IHJldHVybiBiLnRvQmFzZTY0KCk7IH0sXG4gICAgZGVjb2RlKHMpIHsgcmV0dXJuIGRlY29kZUJhc2U2NEJ1aWx0aW4ocywgZmFsc2UpOyB9LFxufSA6IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlNjQgZnJvbSBSRkMgNDY0OC4gTm8gcGFkZGluZy5cbiAqIFVzZSBgYmFzZTY0YCBmb3IgcGFkZGVkIHZlcnNpb24uXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U2NG5vcGFkLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzJ1xuICogYmFzZTY0bm9wYWQuZGVjb2RlKCdFcXMnKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBqb2luKCcnKSk7XG4vKipcbiAqIGJhc2U2NCBmcm9tIFJGQyA0NjQ4LCB1c2luZyBVUkwtc2FmZSBhbHBoYWJldC4gUGFkZGVkLlxuICogVXNlIGBiYXNlNjR1cmxub3BhZGAgZm9yIHVucGFkZGVkIHZlcnNpb24uXG4gKiBGYWxscyBiYWNrIHRvIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogYmFzZTY0dXJsLmVuY29kZShVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKSk7XG4gKiAvLyA9PiAnRXFzPSdcbiAqIGJhc2U2NHVybC5kZWNvZGUoJ0Vxcz0nKTtcbiAqIC8vID0+IFVpbnQ4QXJyYXkuZnJvbShbMHgxMiwgMHhhYl0pXG4gKiBgYGBcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gaGFzQmFzZTY0QnVpbHRpbiA/IHtcbiAgICBlbmNvZGUoYikgeyBhYnl0ZXMoYik7IHJldHVybiBiLnRvQmFzZTY0KHsgYWxwaGFiZXQ6ICdiYXNlNjR1cmwnIH0pOyB9LFxuICAgIGRlY29kZShzKSB7IHJldHVybiBkZWNvZGVCYXNlNjRCdWlsdGluKHMsIHRydWUpOyB9LFxufSA6IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuLyoqXG4gKiBiYXNlNjQgZnJvbSBSRkMgNDY0OCwgdXNpbmcgVVJMLXNhZmUgYWxwaGFiZXQuIE5vIHBhZGRpbmcuXG4gKiBVc2UgYGJhc2U2NHVybGAgZm9yIHBhZGRlZCB2ZXJzaW9uLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBiYXNlNjR1cmxub3BhZC5lbmNvZGUoVWludDhBcnJheS5mcm9tKFsweDEyLCAweGFiXSkpO1xuICogLy8gPT4gJ0VxcydcbiAqIGJhc2U2NHVybG5vcGFkLmRlY29kZSgnRXFzJyk7XG4gKiAvLyA9PiBVaW50OEFycmF5LmZyb20oWzB4MTIsIDB4YWJdKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxub3BhZCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgam9pbignJykpO1xuLy8gYmFzZTU4IGNvZGVcbi8vIC0tLS0tLS0tLS0tXG5jb25zdCBnZW5CYXNlNTggPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAoYWJjKSA9PiBjaGFpbihyYWRpeCg1OCksIGFscGhhYmV0KGFiYyksIGpvaW4oJycpKTtcbi8qKlxuICogYmFzZTU4OiBiYXNlNjQgd2l0aG91dCBhbWJpZ291cyBjaGFyYWN0ZXJzICssIC8sIDAsIE8sIEksIGwuXG4gKiBRdWFkcmF0aWMgKE8obl4yKSkgLSBzbywgY2FuJ3QgYmUgdXNlZCBvbiBsYXJnZSBpbnB1dHMuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGJhc2U1OC5kZWNvZGUoJzAxYWJjZGVmJyk7XG4gKiAvLyA9PiAnM1VoSlcnXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuLyoqXG4gKiBiYXNlNTg6IGZsaWNrciB2ZXJzaW9uLiBDaGVjayBvdXQgYGJhc2U1OGAuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNThmbGlja3IgPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbi8qKlxuICogYmFzZTU4OiBYUlAgdmVyc2lvbi4gQ2hlY2sgb3V0IGBiYXNlNThgLlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyBEYXRhIGxlbiAoaW5kZXgpIC0+IGVuY29kZWQgYmxvY2sgbGVuXG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG4vKipcbiAqIGJhc2U1ODogWE1SIHZlcnNpb24uIENoZWNrIG91dCBgYmFzZTU4YC5cbiAqIERvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4gKiBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuICovXG5leHBvcnQgY29uc3QgYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbi8qKlxuICogTWV0aG9kLCB3aGljaCBjcmVhdGVzIGJhc2U1OGNoZWNrIGVuY29kZXIuXG4gKiBSZXF1aXJlcyBmdW5jdGlvbiwgY2FsY3VsYXRpbmcgc2hhMjU2LlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuLyoqXG4gKiBVc2UgYGNyZWF0ZUJhc2U1OGNoZWNrYCBpbnN0ZWFkLlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OGNoZWNrID0gY3JlYXRlQmFzZTU4Y2hlY2s7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgcG93ZXJzWzMwXV0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBhc3RyKCdiZWNoMzIuZW5jb2RlIHByZWZpeCcsIHByZWZpeCk7XG4gICAgICAgIGlmIChpc0J5dGVzKHdvcmRzKSlcbiAgICAgICAgICAgIHdvcmRzID0gQXJyYXkuZnJvbSh3b3Jkcyk7XG4gICAgICAgIGFudW1BcnIoJ2JlY2gzMi5lbmNvZGUnLCB3b3Jkcyk7XG4gICAgICAgIGNvbnN0IHBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBpZiAocGxlbiA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHJlZml4IGxlbmd0aCAke3BsZW59YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHBsZW4gKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIHJldHVybiBgJHtsb3dlcmVkfTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke3N1bX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGFzdHIoJ2JlY2gzMi5kZWNvZGUgaW5wdXQnLCBzdHIpO1xuICAgICAgICBjb25zdCBzbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHNsZW4gPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc2xlbiA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgc3RyaW5nIGxlbmd0aDogJHtzbGVufSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gbG93ZXJlZC5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbG93ZXJlZC5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBsb3dlcmVkLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKGRhdGEpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFkYXRhLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVGcm9tQnl0ZXMocHJlZml4LCBieXRlcykge1xuICAgICAgICByZXR1cm4gZW5jb2RlKHByZWZpeCwgdG9Xb3JkcyhieXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlRnJvbUJ5dGVzLFxuICAgICAgICBkZWNvZGVUb0J5dGVzLFxuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICB0b1dvcmRzLFxuICAgIH07XG59XG4vKipcbiAqIGJlY2gzMiBmcm9tIEJJUCAxNzMuIE9wZXJhdGVzIG9uIHdvcmRzLlxuICogRm9yIGhpZ2gtbGV2ZWwsIGNoZWNrIG91dCBzY3VyZS1idGMtc2lnbmVyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9zY3VyZS1idGMtc2lnbmVyLlxuICovXG5leHBvcnQgY29uc3QgYmVjaDMyID0gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbi8qKlxuICogYmVjaDMybSBmcm9tIEJJUCAzNTAuIE9wZXJhdGVzIG9uIHdvcmRzLlxuICogSXQgd2FzIHRvIG1pdGlnYXRlIGBiZWNoMzJgIHdlYWtuZXNzZXMuXG4gKiBGb3IgaGlnaC1sZXZlbCwgY2hlY2sgb3V0IHNjdXJlLWJ0Yy1zaWduZXI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJ0Yy1zaWduZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG4vKipcbiAqIFVURi04LXRvLWJ5dGUgZGVjb2Rlci4gVXNlcyBidWlsdC1pbiBUZXh0RGVjb2RlciAvIFRleHRFbmNvZGVyLlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBiID0gdXRmOC5kZWNvZGUoXCJoZXlcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMTA0LCAxMDEsIDEyMSBdKVxuICogY29uc3Qgc3RyID0gdXRmOC5lbmNvZGUoYik7IC8vIFwiaGV5XCJcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgdXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBoYXNIZXhCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB0eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbicpKCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IGhleEJ1aWx0aW4gPSB7XG4gICAgZW5jb2RlKGRhdGEpIHsgYWJ5dGVzKGRhdGEpOyByZXR1cm4gZGF0YS50b0hleCgpOyB9LFxuICAgIGRlY29kZShzKSB7IGFzdHIoJ2hleCcsIHMpOyByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KHMpOyB9LFxufTtcbi8qKlxuICogaGV4IHN0cmluZyBkZWNvZGVyLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgYiA9IGhleC5kZWNvZGUoXCIwMTAyZmZcIik7IC8vID0+IG5ldyBVaW50OEFycmF5KFsgMSwgMiwgMjU1IF0pXG4gKiBjb25zdCBzdHIgPSBoZXguZW5jb2RlKGIpOyAvLyBcIjAxMDJmZlwiXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGhleCA9IGhhc0hleEJ1aWx0aW5cbiAgICA/IGhleEJ1aWx0aW5cbiAgICA6IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG4gICAgfSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7IC8vIGFzIGluIHB5dGhvbiwgYnV0IGZvciBieXRlcyBvbmx5XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgY29uc3QgYnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYWJ5dGVzIiwiYiIsImxlbmd0aHMiLCJFcnJvciIsImxlbmd0aCIsImluY2x1ZGVzIiwiaXNBcnJheU9mIiwiaXNTdHJpbmciLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJldmVyeSIsIml0ZW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiYWZuIiwiaW5wdXQiLCJhc3RyIiwibGFiZWwiLCJhbnVtYmVyIiwibiIsImFBcnIiLCJhc3RyQXJyIiwiYW51bUFyciIsImNoYWluIiwiYXJncyIsImlkIiwid3JhcCIsImMiLCJlbmNvZGUiLCJtYXAiLCJ4IiwicmVkdWNlUmlnaHQiLCJkZWNvZGUiLCJyZWR1Y2UiLCJhbHBoYWJldCIsImxldHRlcnMiLCJsZXR0ZXJzQSIsInNwbGl0IiwibGVuIiwiaW5kZXhlcyIsIk1hcCIsImwiLCJpIiwiZGlnaXRzIiwibGV0dGVyIiwiZ2V0IiwidW5kZWZpbmVkIiwiam9pbiIsInNlcGFyYXRvciIsImZyb20iLCJ0byIsInBhZGRpbmciLCJiaXRzIiwiY2hyIiwiZGF0YSIsInB1c2giLCJlbmQiLCJsYXN0IiwiYnl0ZSIsInNsaWNlIiwibm9ybWFsaXplIiwiZm4iLCJjb252ZXJ0UmFkaXgiLCJwb3MiLCJyZXMiLCJkIiwiZGxlbiIsImNhcnJ5IiwiZG9uZSIsImRpZ2l0IiwiZnJvbUNhcnJ5IiwiZGlnaXRCYXNlIiwiZGl2Iiwicm91bmRlZCIsIk1hdGgiLCJmbG9vciIsInJldmVyc2UiLCJnY2QiLCJyYWRpeDJjYXJyeSIsInBvd2VycyIsImNvbnZlcnRSYWRpeDIiLCJtYXgiLCJtYXNrIiwicG93IiwicmFkaXgiLCJudW0iLCJfMjU2IiwiYnl0ZXMiLCJyYWRpeDIiLCJyZXZQYWRkaW5nIiwidW5zYWZlV3JhcHBlciIsImFwcGx5IiwiZSIsImNoZWNrc3VtIiwic3VtIiwic2V0IiwicGF5bG9hZCIsIm9sZENoZWNrc3VtIiwibmV3Q2hlY2tzdW0iLCJ1dGlscyIsImJhc2UxNiIsImJhc2UzMiIsImJhc2UzMm5vcGFkIiwiYmFzZTMyaGV4IiwiYmFzZTMyaGV4bm9wYWQiLCJiYXNlMzJjcm9ja2ZvcmQiLCJzIiwidG9VcHBlckNhc2UiLCJyZXBsYWNlIiwiaGFzQmFzZTY0QnVpbHRpbiIsInRvQmFzZTY0IiwiZnJvbUJhc2U2NCIsImRlY29kZUJhc2U2NEJ1aWx0aW4iLCJpc1VybCIsInJlIiwidGVzdCIsImxhc3RDaHVua0hhbmRsaW5nIiwiYmFzZTY0IiwiYmFzZTY0bm9wYWQiLCJiYXNlNjR1cmwiLCJiYXNlNjR1cmxub3BhZCIsImdlbkJhc2U1OCIsImFiYyIsImJhc2U1OCIsImJhc2U1OGZsaWNrciIsImJhc2U1OHhycCIsIlhNUl9CTE9DS19MRU4iLCJiYXNlNTh4bXIiLCJibG9jayIsInN1YmFycmF5IiwicGFkU3RhcnQiLCJzdHIiLCJibG9ja0xlbiIsImluZGV4T2YiLCJqIiwiY29uY2F0IiwiY3JlYXRlQmFzZTU4Y2hlY2siLCJzaGEyNTYiLCJiYXNlNThjaGVjayIsIkJFQ0hfQUxQSEFCRVQiLCJQT0xZTU9EX0dFTkVSQVRPUlMiLCJiZWNoMzJQb2x5bW9kIiwicHJlIiwiY2hrIiwiYmVjaENoZWNrc3VtIiwicHJlZml4Iiwid29yZHMiLCJlbmNvZGluZ0NvbnN0IiwiY2hhckNvZGVBdCIsInYiLCJnZW5CZWNoMzIiLCJlbmNvZGluZyIsIkVOQ09ESU5HX0NPTlNUIiwiX3dvcmRzIiwiZnJvbVdvcmRzIiwidG9Xb3JkcyIsImZyb21Xb3Jkc1Vuc2FmZSIsImxpbWl0IiwicGxlbiIsIlR5cGVFcnJvciIsImFjdHVhbExlbmd0aCIsImxvd2VyZWQiLCJ0b0xvd2VyQ2FzZSIsInNsZW4iLCJzZXBJbmRleCIsImxhc3RJbmRleE9mIiwiZW5kc1dpdGgiLCJkZWNvZGVVbnNhZmUiLCJkZWNvZGVUb0J5dGVzIiwiZW5jb2RlRnJvbUJ5dGVzIiwiYmVjaDMyIiwiYmVjaDMybSIsInV0ZjgiLCJUZXh0RGVjb2RlciIsIlRleHRFbmNvZGVyIiwiaGFzSGV4QnVpbHRpbiIsInRvSGV4IiwiZnJvbUhleCIsImhleEJ1aWx0aW4iLCJoZXgiLCJDT0RFUlMiLCJjb2RlclR5cGVFcnJvciIsImJ5dGVzVG9TdHJpbmciLCJ0eXBlIiwiaGFzT3duUHJvcGVydHkiLCJzdHJpbmdUb0J5dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@scure/bip32/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HARDENED_OFFSET: () => (/* binding */ HARDENED_OFFSET),\n/* harmony export */   HDKey: () => (/* binding */ HDKey)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_legacy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/legacy */ \"(ssr)/./node_modules/@noble/hashes/esm/legacy.js\");\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/**\n * @module BIP32 hierarchical deterministic (HD) wallets over secp256k1.\n * @example\n * ```js\n * import { HDKey } from \"@scure/bip32\";\n * const hdkey1 = HDKey.fromMasterSeed(seed);\n * const hdkey2 = HDKey.fromExtendedKey(base58key);\n * const hdkey3 = HDKey.fromJSON({ xpriv: string });\n *\n * // props\n * [hdkey1.depth, hdkey1.index, hdkey1.chainCode];\n * console.log(hdkey2.privateKey, hdkey2.publicKey);\n * console.log(hdkey3.derive(\"m/0/2147483647'/1\"));\n * const sig = hdkey3.sign(hash);\n * hdkey3.verify(hash, sig);\n * ```\n */ /*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst Point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint;\nconst base58check = (0,_scure_base__WEBPACK_IMPORTED_MODULE_1__.createBase58check)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256);\nfunction bytesToNumber(bytes) {\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes);\n    const h = bytes.length === 0 ? \"0\" : (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.bytesToHex)(bytes);\n    return BigInt(\"0x\" + h);\n}\nfunction numberToBytes(num) {\n    if (typeof num !== \"bigint\") throw new Error(\"bigint expected\");\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(num.toString(16).padStart(64, \"0\"));\n}\nconst MASTER_SECRET = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)(\"Bitcoin seed\");\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = {\n    private: 0x0488ade4,\n    public: 0x0488b21e\n};\nconst HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data)=>(0,_noble_hashes_legacy__WEBPACK_IMPORTED_MODULE_4__.ripemd160)((0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)(data));\nconst fromU32 = (data)=>(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(data).getUint32(0, false);\nconst toU32 = (n)=>{\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error(\"invalid number, should be from 0 to 2**32-1, got \" + n);\n    }\n    const buf = new Uint8Array(4);\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(buf).setUint32(0, n, false);\n    return buf;\n};\nclass HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error(\"No publicKey set!\");\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error(\"No private key\");\n        }\n        return base58check.encode(this.serialize(this.versions.private, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(new Uint8Array([\n            0\n        ]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error(\"No public key\");\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.abytes)(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error(\"HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got \" + seed.length);\n        }\n        const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_5__.hmac)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32)\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45)\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? \"private\" : \"public\"]) {\n            throw new Error(\"Version mismatch\");\n        }\n        if (isPriv) {\n            return new HDKey({\n                ...opt,\n                privateKey: key.slice(1)\n            });\n        } else {\n            return new HDKey({\n                ...opt,\n                publicKey: key\n            });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt){\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== \"object\") {\n            throw new Error(\"HDKey.constructor must not be called directly\");\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode || null;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error(\"HDKey: zero depth with non-zero index/parent fingerprint\");\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error(\"HDKey: publicKey and privateKey at same time.\");\n        }\n        if (opt.privateKey) {\n            if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error(\"Invalid private key\");\n            }\n            this.privKey = typeof opt.privateKey === \"bigint\" ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.getPublicKey(opt.privateKey, true);\n        } else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        } else {\n            throw new Error(\"HDKey: no public or private key provided\");\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, \"\").split(\"/\");\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts){\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== \"string\") throw new Error(\"invalid child index: \" + c);\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error(\"Invalid index\");\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error(\"No publicKey or chainCode set\");\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error(\"Could not derive hardened child key\");\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(new Uint8Array([\n                0\n            ]), priv, data);\n        } else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(this.pubKey, data);\n        }\n        const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_5__.hmac)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(childTweak)) {\n            throw new Error(\"Tweak bigger than curve order\");\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_6__.mod)(this.privKey + childTweak, _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.CURVE.n);\n                if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(added)) {\n                    throw new Error(\"The tweak was out of range or the resulted private key is invalid\");\n                }\n                opt.privateKey = added;\n            } else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error(\"The tweak was equal to negative P, which made the result key invalid\");\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        } catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error(\"No privateKey set!\");\n        }\n        (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.abytes)(hash, 32);\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.abytes)(hash, 32);\n        (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.abytes)(signature, 64);\n        if (!this.publicKey) {\n            throw new Error(\"No publicKey set!\");\n        }\n        let sig;\n        try {\n            sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature.fromCompact(signature);\n        } catch (error) {\n            return false;\n        }\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error(\"No chainCode set\");\n        }\n        (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.abytes)(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(toU32(version), new Uint8Array([\n            this.depth\n        ]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDRCx1RkFBdUYsR0FDbEM7QUFDTztBQUNsQjtBQUNPO0FBQ0c7QUFDd0Q7QUFDNUQ7QUFDaEQsTUFBTWMsUUFBUVosOERBQUlBLENBQUNhLGVBQWU7QUFDbEMsTUFBTUMsY0FBY0gsOERBQWlCQSxDQUFDUixzREFBTUE7QUFDNUMsU0FBU1ksY0FBY0MsS0FBSztJQUN4QlgsMkRBQU1BLENBQUNXO0lBQ1AsTUFBTUMsSUFBSUQsTUFBTUUsTUFBTSxLQUFLLElBQUksTUFBTVosK0RBQVVBLENBQUNVO0lBQ2hELE9BQU9HLE9BQU8sT0FBT0Y7QUFDekI7QUFDQSxTQUFTRyxjQUFjQyxHQUFHO0lBQ3RCLElBQUksT0FBT0EsUUFBUSxVQUNmLE1BQU0sSUFBSUMsTUFBTTtJQUNwQixPQUFPYiwrREFBVUEsQ0FBQ1ksSUFBSUUsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxJQUFJO0FBQ3BEO0FBQ0EsTUFBTUMsZ0JBQWdCZixnRUFBV0EsQ0FBQztBQUNsQywrQkFBK0I7QUFDL0IsTUFBTWdCLG1CQUFtQjtJQUFFQyxTQUFTO0lBQVlDLFFBQVE7QUFBVztBQUM1RCxNQUFNQyxrQkFBa0IsV0FBVztBQUMxQyxNQUFNQyxVQUFVLENBQUNDLE9BQVM3QiwrREFBU0EsQ0FBQ0MsMERBQU1BLENBQUM0QjtBQUMzQyxNQUFNQyxVQUFVLENBQUNELE9BQVN2QiwrREFBVUEsQ0FBQ3VCLE1BQU1FLFNBQVMsQ0FBQyxHQUFHO0FBQ3hELE1BQU1DLFFBQVEsQ0FBQ0M7SUFDWCxJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTUEsSUFBSSxLQUFLQSxJQUFJLEtBQUssS0FBSyxHQUFHO1FBQ3RELE1BQU0sSUFBSWIsTUFBTSxzREFBc0RhO0lBQzFFO0lBQ0EsTUFBTUcsTUFBTSxJQUFJQyxX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cy9Ac2N1cmUvYmlwMzIvbGliL2VzbS9pbmRleC5qcz9lZmU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBCSVAzMiBoaWVyYXJjaGljYWwgZGV0ZXJtaW5pc3RpYyAoSEQpIHdhbGxldHMgb3ZlciBzZWNwMjU2azEuXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IEhES2V5IH0gZnJvbSBcIkBzY3VyZS9iaXAzMlwiO1xuICogY29uc3QgaGRrZXkxID0gSERLZXkuZnJvbU1hc3RlclNlZWQoc2VlZCk7XG4gKiBjb25zdCBoZGtleTIgPSBIREtleS5mcm9tRXh0ZW5kZWRLZXkoYmFzZTU4a2V5KTtcbiAqIGNvbnN0IGhka2V5MyA9IEhES2V5LmZyb21KU09OKHsgeHByaXY6IHN0cmluZyB9KTtcbiAqXG4gKiAvLyBwcm9wc1xuICogW2hka2V5MS5kZXB0aCwgaGRrZXkxLmluZGV4LCBoZGtleTEuY2hhaW5Db2RlXTtcbiAqIGNvbnNvbGUubG9nKGhka2V5Mi5wcml2YXRlS2V5LCBoZGtleTIucHVibGljS2V5KTtcbiAqIGNvbnNvbGUubG9nKGhka2V5My5kZXJpdmUoXCJtLzAvMjE0NzQ4MzY0NycvMVwiKSk7XG4gKiBjb25zdCBzaWcgPSBoZGtleTMuc2lnbihoYXNoKTtcbiAqIGhka2V5My52ZXJpZnkoaGFzaCwgc2lnKTtcbiAqIGBgYFxuICovXG4vKiEgc2N1cmUtYmlwMzIgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXRyaWNpbyBQYWxsYWRpbm8sIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgbW9kIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJztcbmltcG9ydCB7IHNlY3AyNTZrMSBhcyBzZWNwIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyByaXBlbWQxNjAgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2xlZ2FjeSc7XG5pbXBvcnQgeyBzaGEyNTYsIHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgeyBhYnl0ZXMsIGJ5dGVzVG9IZXgsIGNvbmNhdEJ5dGVzLCBjcmVhdGVWaWV3LCBoZXhUb0J5dGVzLCB1dGY4VG9CeXRlcywgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUJhc2U1OGNoZWNrIH0gZnJvbSAnQHNjdXJlL2Jhc2UnO1xuY29uc3QgUG9pbnQgPSBzZWNwLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IGJhc2U1OGNoZWNrID0gY3JlYXRlQmFzZTU4Y2hlY2soc2hhMjU2KTtcbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGggPSBieXRlcy5sZW5ndGggPT09IDAgPyAnMCcgOiBieXRlc1RvSGV4KGJ5dGVzKTtcbiAgICByZXR1cm4gQmlnSW50KCcweCcgKyBoKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXMobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJykpO1xufVxuY29uc3QgTUFTVEVSX1NFQ1JFVCA9IHV0ZjhUb0J5dGVzKCdCaXRjb2luIHNlZWQnKTtcbi8vIEJpdGNvaW4gaGFyZGNvZGVkIGJ5IGRlZmF1bHRcbmNvbnN0IEJJVENPSU5fVkVSU0lPTlMgPSB7IHByaXZhdGU6IDB4MDQ4OGFkZTQsIHB1YmxpYzogMHgwNDg4YjIxZSB9O1xuZXhwb3J0IGNvbnN0IEhBUkRFTkVEX09GRlNFVCA9IDB4ODAwMDAwMDA7XG5jb25zdCBoYXNoMTYwID0gKGRhdGEpID0+IHJpcGVtZDE2MChzaGEyNTYoZGF0YSkpO1xuY29uc3QgZnJvbVUzMiA9IChkYXRhKSA9PiBjcmVhdGVWaWV3KGRhdGEpLmdldFVpbnQzMigwLCBmYWxzZSk7XG5jb25zdCB0b1UzMiA9IChuKSA9PiB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCB8fCBuID4gMiAqKiAzMiAtIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG51bWJlciwgc2hvdWxkIGJlIGZyb20gMCB0byAyKiozMi0xLCBnb3QgJyArIG4pO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjcmVhdGVWaWV3KGJ1Zikuc2V0VWludDMyKDAsIG4sIGZhbHNlKTtcbiAgICByZXR1cm4gYnVmO1xufTtcbmV4cG9ydCBjbGFzcyBIREtleSB7XG4gICAgZ2V0IGZpbmdlcnByaW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucHViSGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgc2V0IScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tVTMyKHRoaXMucHViSGFzaCk7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJIYXNoO1xuICAgIH1cbiAgICBnZXQgcHViS2V5SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZLZXlCeXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJLZXkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgaWYgKCFwcml2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnByaXZhdGUsIGNvbmNhdEJ5dGVzKG5ldyBVaW50OEFycmF5KFswXSksIHByaXYpKSk7XG4gICAgfVxuICAgIGdldCBwdWJsaWNFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YktleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWMga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnB1YmxpYywgdGhpcy5wdWJLZXkpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21NYXN0ZXJTZWVkKHNlZWQsIHZlcnNpb25zID0gQklUQ09JTl9WRVJTSU9OUykge1xuICAgICAgICBhYnl0ZXMoc2VlZCk7XG4gICAgICAgIGlmICg4ICogc2VlZC5sZW5ndGggPCAxMjggfHwgOCAqIHNlZWQubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hES2V5OiBzZWVkIGxlbmd0aCBtdXN0IGJlIGJldHdlZW4gMTI4IGFuZCA1MTIgYml0czsgMjU2IGJpdHMgaXMgYWR2aXNlZCwgZ290ICcgK1xuICAgICAgICAgICAgICAgIHNlZWQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBJID0gaG1hYyhzaGE1MTIsIE1BU1RFUl9TRUNSRVQsIHNlZWQpO1xuICAgICAgICByZXR1cm4gbmV3IEhES2V5KHtcbiAgICAgICAgICAgIHZlcnNpb25zLFxuICAgICAgICAgICAgY2hhaW5Db2RlOiBJLnNsaWNlKDMyKSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IEkuc2xpY2UoMCwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEtleShiYXNlNThrZXksIHZlcnNpb25zID0gQklUQ09JTl9WRVJTSU9OUykge1xuICAgICAgICAvLyA9PiB2ZXJzaW9uKDQpIHx8IGRlcHRoKDEpIHx8IGZpbmdlcnByaW50KDQpIHx8IGluZGV4KDQpIHx8IGNoYWluKDMyKSB8fCBrZXkoMzMpXG4gICAgICAgIGNvbnN0IGtleUJ1ZmZlciA9IGJhc2U1OGNoZWNrLmRlY29kZShiYXNlNThrZXkpO1xuICAgICAgICBjb25zdCBrZXlWaWV3ID0gY3JlYXRlVmlldyhrZXlCdWZmZXIpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0ga2V5Vmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9ucyxcbiAgICAgICAgICAgIGRlcHRoOiBrZXlCdWZmZXJbNF0sXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDoga2V5Vmlldy5nZXRVaW50MzIoNSwgZmFsc2UpLFxuICAgICAgICAgICAgaW5kZXg6IGtleVZpZXcuZ2V0VWludDMyKDksIGZhbHNlKSxcbiAgICAgICAgICAgIGNoYWluQ29kZToga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGtleSA9IGtleUJ1ZmZlci5zbGljZSg0NSk7XG4gICAgICAgIGNvbnN0IGlzUHJpdiA9IGtleVswXSA9PT0gMDtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IHZlcnNpb25zW2lzUHJpdiA/ICdwcml2YXRlJyA6ICdwdWJsaWMnXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJpdikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHJpdmF0ZUtleToga2V5LnNsaWNlKDEpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHVibGljS2V5OiBrZXkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIEhES2V5LmZyb21FeHRlbmRlZEtleShqc29uLnhwcml2KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMDtcbiAgICAgICAgaWYgKCFvcHQgfHwgdHlwZW9mIG9wdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXkuY29uc3RydWN0b3IgbXVzdCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9ucyA9IG9wdC52ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TO1xuICAgICAgICB0aGlzLmRlcHRoID0gb3B0LmRlcHRoIHx8IDA7XG4gICAgICAgIHRoaXMuY2hhaW5Db2RlID0gb3B0LmNoYWluQ29kZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmluZGV4ID0gb3B0LmluZGV4IHx8IDA7XG4gICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSBvcHQucGFyZW50RmluZ2VycHJpbnQgfHwgMDtcbiAgICAgICAgaWYgKCF0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRGaW5nZXJwcmludCB8fCB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleTogemVybyBkZXB0aCB3aXRoIG5vbi16ZXJvIGluZGV4L3BhcmVudCBmaW5nZXJwcmludCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHQucHVibGljS2V5ICYmIG9wdC5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hES2V5OiBwdWJsaWNLZXkgYW5kIHByaXZhdGVLZXkgYXQgc2FtZSB0aW1lLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgaWYgKCFzZWNwLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KG9wdC5wcml2YXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIGtleScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcml2S2V5ID1cbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0LnByaXZhdGVLZXkgPT09ICdiaWdpbnQnID8gb3B0LnByaXZhdGVLZXkgOiBieXRlc1RvTnVtYmVyKG9wdC5wcml2YXRlS2V5KTtcbiAgICAgICAgICAgIHRoaXMucHJpdktleUJ5dGVzID0gbnVtYmVyVG9CeXRlcyh0aGlzLnByaXZLZXkpO1xuICAgICAgICAgICAgdGhpcy5wdWJLZXkgPSBzZWNwLmdldFB1YmxpY0tleShvcHQucHJpdmF0ZUtleSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0LnB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhpcy5wdWJLZXkgPSBQb2ludC5mcm9tSGV4KG9wdC5wdWJsaWNLZXkpLnRvUmF3Qnl0ZXModHJ1ZSk7IC8vIGZvcmNlIGNvbXByZXNzZWQgcG9pbnRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXk6IG5vIHB1YmxpYyBvciBwcml2YXRlIGtleSBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHViSGFzaCA9IGhhc2gxNjAodGhpcy5wdWJLZXkpO1xuICAgIH1cbiAgICBkZXJpdmUocGF0aCkge1xuICAgICAgICBpZiAoIS9eW21NXSc/Ly50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbXVzdCBzdGFydCB3aXRoIFwibVwiIG9yIFwiTVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eW21NXSc/JC8udGVzdChwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBwYXRoLnJlcGxhY2UoL15bbU1dJz9cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGxldCBjaGlsZCA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgbSA9IC9eKFxcZCspKCc/KSQvLmV4ZWMoYyk7XG4gICAgICAgICAgICBjb25zdCBtMSA9IG0gJiYgbVsxXTtcbiAgICAgICAgICAgIGlmICghbSB8fCBtLmxlbmd0aCAhPT0gMyB8fCB0eXBlb2YgbTEgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaGlsZCBpbmRleDogJyArIGMpO1xuICAgICAgICAgICAgbGV0IGlkeCA9ICttMTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaWR4KSB8fCBpZHggPj0gSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYXJkZW5lZCBrZXlcbiAgICAgICAgICAgIGlmIChtWzJdID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIGlkeCArPSBIQVJERU5FRF9PRkZTRVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmRlcml2ZUNoaWxkKGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBkZXJpdmVDaGlsZChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMucHViS2V5IHx8ICF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgb3IgY2hhaW5Db2RlIHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gdG9VMzIoaW5kZXgpO1xuICAgICAgICBpZiAoaW5kZXggPj0gSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAvLyBIYXJkZW5lZFxuICAgICAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGlmICghcHJpdikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhcmRlbmVkIGNoaWxkOiAweDAwIHx8IHNlcjI1NihrcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICAgICAgICAgIGRhdGEgPSBjb25jYXRCeXRlcyhuZXcgVWludDhBcnJheShbMF0pLCBwcml2LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbCBjaGlsZDogc2VyUChwb2ludChrcGFyKSkgfHwgc2VyMzIoaW5kZXgpXG4gICAgICAgICAgICBkYXRhID0gY29uY2F0Qnl0ZXModGhpcy5wdWJLZXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEkgPSBobWFjKHNoYTUxMiwgdGhpcy5jaGFpbkNvZGUsIGRhdGEpO1xuICAgICAgICBjb25zdCBjaGlsZFR3ZWFrID0gYnl0ZXNUb051bWJlcihJLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IEkuc2xpY2UoMzIpO1xuICAgICAgICBpZiAoIXNlY3AudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoY2hpbGRUd2VhaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHdlYWsgYmlnZ2VyIHRoYW4gY3VydmUgb3JkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uczogdGhpcy52ZXJzaW9ucyxcbiAgICAgICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoICsgMSxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZCA9IG1vZCh0aGlzLnByaXZLZXkgKyBjaGlsZFR3ZWFrLCBzZWNwLkNVUlZFLm4pO1xuICAgICAgICAgICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShhZGRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciB0aGUgcmVzdWx0ZWQgcHJpdmF0ZSBrZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHQucHJpdmF0ZUtleSA9IGFkZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWQgPSBQb2ludC5mcm9tSGV4KHRoaXMucHViS2V5KS5hZGQoUG9pbnQuZnJvbVByaXZhdGVLZXkoY2hpbGRUd2VhaykpO1xuICAgICAgICAgICAgICAgIC8vIENyeXB0b2dyYXBoaWNhbGx5IGltcG9zc2libGU6IGhtYWMtc2hhNTEyIHByZWltYWdlIHdvdWxkIG5lZWQgdG8gYmUgZm91bmRcbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQuZXF1YWxzKFBvaW50LlpFUk8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHR3ZWFrIHdhcyBlcXVhbCB0byBuZWdhdGl2ZSBQLCB3aGljaCBtYWRlIHRoZSByZXN1bHQga2V5IGludmFsaWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0LnB1YmxpY0tleSA9IGFkZGVkLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhES2V5KG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlQ2hpbGQoaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaWduKGhhc2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJpdmF0ZUtleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgYWJ5dGVzKGhhc2gsIDMyKTtcbiAgICAgICAgcmV0dXJuIHNlY3Auc2lnbihoYXNoLCB0aGlzLnByaXZLZXkpLnRvQ29tcGFjdFJhd0J5dGVzKCk7XG4gICAgfVxuICAgIHZlcmlmeShoYXNoLCBzaWduYXR1cmUpIHtcbiAgICAgICAgYWJ5dGVzKGhhc2gsIDMyKTtcbiAgICAgICAgYWJ5dGVzKHNpZ25hdHVyZSwgNjQpO1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpY0tleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZyA9IHNlY3AuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3AudmVyaWZ5KHNpZywgaGFzaCwgdGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbiAgICB3aXBlUHJpdmF0ZURhdGEoKSB7XG4gICAgICAgIHRoaXMucHJpdktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMucHJpdktleUJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy5wcml2S2V5Qnl0ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICAgICAgICAgIHhwdWI6IHRoaXMucHVibGljRXh0ZW5kZWRLZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2ZXJzaW9uLCBrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFpbkNvZGUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYWJ5dGVzKGtleSwgMzMpO1xuICAgICAgICAvLyB2ZXJzaW9uKDQpIHx8IGRlcHRoKDEpIHx8IGZpbmdlcnByaW50KDQpIHx8IGluZGV4KDQpIHx8IGNoYWluKDMyKSB8fCBrZXkoMzMpXG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyh0b1UzMih2ZXJzaW9uKSwgbmV3IFVpbnQ4QXJyYXkoW3RoaXMuZGVwdGhdKSwgdG9VMzIodGhpcy5wYXJlbnRGaW5nZXJwcmludCksIHRvVTMyKHRoaXMuaW5kZXgpLCB0aGlzLmNoYWluQ29kZSwga2V5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsibW9kIiwic2VjcDI1NmsxIiwic2VjcCIsImhtYWMiLCJyaXBlbWQxNjAiLCJzaGEyNTYiLCJzaGE1MTIiLCJhYnl0ZXMiLCJieXRlc1RvSGV4IiwiY29uY2F0Qnl0ZXMiLCJjcmVhdGVWaWV3IiwiaGV4VG9CeXRlcyIsInV0ZjhUb0J5dGVzIiwiY3JlYXRlQmFzZTU4Y2hlY2siLCJQb2ludCIsIlByb2plY3RpdmVQb2ludCIsImJhc2U1OGNoZWNrIiwiYnl0ZXNUb051bWJlciIsImJ5dGVzIiwiaCIsImxlbmd0aCIsIkJpZ0ludCIsIm51bWJlclRvQnl0ZXMiLCJudW0iLCJFcnJvciIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJNQVNURVJfU0VDUkVUIiwiQklUQ09JTl9WRVJTSU9OUyIsInByaXZhdGUiLCJwdWJsaWMiLCJIQVJERU5FRF9PRkZTRVQiLCJoYXNoMTYwIiwiZGF0YSIsImZyb21VMzIiLCJnZXRVaW50MzIiLCJ0b1UzMiIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiYnVmIiwiVWludDhBcnJheSIsInNldFVpbnQzMiIsIkhES2V5IiwiZmluZ2VycHJpbnQiLCJwdWJIYXNoIiwiaWRlbnRpZmllciIsInB1YktleUhhc2giLCJwcml2YXRlS2V5IiwicHJpdktleUJ5dGVzIiwicHVibGljS2V5IiwicHViS2V5IiwicHJpdmF0ZUV4dGVuZGVkS2V5IiwicHJpdiIsImVuY29kZSIsInNlcmlhbGl6ZSIsInZlcnNpb25zIiwicHVibGljRXh0ZW5kZWRLZXkiLCJmcm9tTWFzdGVyU2VlZCIsInNlZWQiLCJJIiwiY2hhaW5Db2RlIiwic2xpY2UiLCJmcm9tRXh0ZW5kZWRLZXkiLCJiYXNlNThrZXkiLCJrZXlCdWZmZXIiLCJkZWNvZGUiLCJrZXlWaWV3IiwidmVyc2lvbiIsIm9wdCIsImRlcHRoIiwicGFyZW50RmluZ2VycHJpbnQiLCJpbmRleCIsImtleSIsImlzUHJpdiIsImZyb21KU09OIiwianNvbiIsInhwcml2IiwiY29uc3RydWN0b3IiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicHJpdktleSIsImdldFB1YmxpY0tleSIsImZyb21IZXgiLCJ0b1Jhd0J5dGVzIiwiZGVyaXZlIiwicGF0aCIsInRlc3QiLCJwYXJ0cyIsInJlcGxhY2UiLCJzcGxpdCIsImNoaWxkIiwiYyIsIm0iLCJleGVjIiwibTEiLCJpZHgiLCJkZXJpdmVDaGlsZCIsImNoaWxkVHdlYWsiLCJhZGRlZCIsIkNVUlZFIiwiYWRkIiwiZnJvbVByaXZhdGVLZXkiLCJlcXVhbHMiLCJaRVJPIiwiZXJyIiwic2lnbiIsImhhc2giLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInZlcmlmeSIsInNpZ25hdHVyZSIsInNpZyIsIlNpZ25hdHVyZSIsImZyb21Db21wYWN0IiwiZXJyb3IiLCJ3aXBlUHJpdmF0ZURhdGEiLCJ1bmRlZmluZWQiLCJmaWxsIiwidG9KU09OIiwieHB1YiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@scure/bip39/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entropyToMnemonic: () => (/* binding */ entropyToMnemonic),\n/* harmony export */   generateMnemonic: () => (/* binding */ generateMnemonic),\n/* harmony export */   mnemonicToEntropy: () => (/* binding */ mnemonicToEntropy),\n/* harmony export */   mnemonicToSeed: () => (/* binding */ mnemonicToSeed),\n/* harmony export */   mnemonicToSeedSync: () => (/* binding */ mnemonicToSeedSync),\n/* harmony export */   validateMnemonic: () => (/* binding */ validateMnemonic)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/**\n * Audited & minimal JS implementation of\n * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @module\n * @example\n```js\nimport * as bip39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nconst mn = bip39.generateMnemonic(wordlist);\nconsole.log(mn);\nconst ent = bip39.mnemonicToEntropy(mn, wordlist)\nbip39.entropyToMnemonic(ent, wordlist);\nbip39.validateMnemonic(mn, wordlist);\nawait bip39.mnemonicToSeed(mn, 'password');\nbip39.mnemonicToSeedSync(mn, 'password');\n\n// Wordlists\nimport { wordlist as czech } from '@scure/bip39/wordlists/czech';\nimport { wordlist as english } from '@scure/bip39/wordlists/english';\nimport { wordlist as french } from '@scure/bip39/wordlists/french';\nimport { wordlist as italian } from '@scure/bip39/wordlists/italian';\nimport { wordlist as japanese } from '@scure/bip39/wordlists/japanese';\nimport { wordlist as korean } from '@scure/bip39/wordlists/korean';\nimport { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';\nimport { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';\nimport { wordlist as spanish } from '@scure/bip39/wordlists/spanish';\nimport { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';\n```\n */ /*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */ \n\n\n\n// Japanese wordlist\nconst isJapanese = (wordlist)=>wordlist[0] === \"\";\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== \"string\") throw new TypeError(\"invalid mnemonic type: \" + typeof str);\n    return str.normalize(\"NFKD\");\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(\" \");\n    if (![\n        12,\n        15,\n        18,\n        21,\n        24\n    ].includes(words.length)) throw new Error(\"Invalid mnemonic\");\n    return {\n        nfkd: norm,\n        words\n    };\n}\nfunction aentropy(ent) {\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.abytes)(ent, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */ function generateMnemonic(wordlist, strength = 128) {\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.anumber)(strength);\n    if (strength % 32 !== 0 || strength > 256) throw new TypeError(\"Invalid entropy\");\n    return entropyToMnemonic((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy)=>{\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([\n        (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha256)(entropy)[0] >> bitsLeft << bitsLeft\n    ]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== \"string\") throw new Error(\"Wordlist: expected array of 2048 strings\");\n    wordlist.forEach((i)=>{\n        if (typeof i !== \"string\") throw new Error(\"wordlist: non-string element: \" + i);\n    });\n    return _scure_base__WEBPACK_IMPORTED_MODULE_2__.utils.chain(_scure_base__WEBPACK_IMPORTED_MODULE_2__.utils.checksum(1, calcChecksum), _scure_base__WEBPACK_IMPORTED_MODULE_2__.utils.radix2(11, true), _scure_base__WEBPACK_IMPORTED_MODULE_2__.utils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */ function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */ function entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? \"\" : \" \");\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */ function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase)=>nfkd(\"mnemonic\" + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */ function mnemonicToSeed(mnemonic, passphrase = \"\") {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__.pbkdf2Async)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha512, normalize(mnemonic).nfkd, psalt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */ function mnemonicToSeedSync(mnemonic, passphrase = \"\") {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_3__.pbkdf2)(_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_1__.sha512, normalize(mnemonic).nfkd, psalt(passphrase), {\n        c: 2048,\n        dkLen: 64\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDRCx1RkFBdUYsR0FDNUI7QUFDUDtBQUNlO0FBQ2xCO0FBQ2pELG9CQUFvQjtBQUNwQixNQUFNUyxhQUFhLENBQUNDLFdBQWFBLFFBQVEsQ0FBQyxFQUFFLEtBQUs7QUFDakQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCxvRkFBb0Y7QUFDcEYsK0NBQStDO0FBQy9DLFNBQVNDLEtBQUtDLEdBQUc7SUFDYixJQUFJLE9BQU9BLFFBQVEsVUFDZixNQUFNLElBQUlDLFVBQVUsNEJBQTRCLE9BQU9EO0lBQzNELE9BQU9BLElBQUlFLFNBQVMsQ0FBQztBQUN6QjtBQUNBLFNBQVNBLFVBQVVGLEdBQUc7SUFDbEIsTUFBTUcsT0FBT0osS0FBS0M7SUFDbEIsTUFBTUksUUFBUUQsS0FBS0UsS0FBSyxDQUFDO0lBQ3pCLElBQUksQ0FBQztRQUFDO1FBQUk7UUFBSTtRQUFJO1FBQUk7S0FBRyxDQUFDQyxRQUFRLENBQUNGLE1BQU1HLE1BQU0sR0FDM0MsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCLE9BQU87UUFBRVQsTUFBTUk7UUFBTUM7SUFBTTtBQUMvQjtBQUNBLFNBQVNLLFNBQVNDLEdBQUc7SUFDakJsQiwyREFBTUEsQ0FBQ2tCLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSTtBQUNoQztBQUNBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTQyxpQkFBaUJiLFFBQVEsRUFBRWMsV0FBVyxHQUFHO0lBQ3JEbkIsNERBQU9BLENBQUNtQjtJQUNSLElBQUlBLFdBQVcsT0FBTyxLQUFLQSxXQUFXLEtBQ2xDLE1BQU0sSUFBSVgsVUFBVTtJQUN4QixPQUFPWSxrQkFBa0JuQixnRUFBV0EsQ0FBQ2tCLFdBQVcsSUFBSWQ7QUFDeEQ7QUFDQSxNQUFNZ0IsZUFBZSxDQUFDQztJQUNsQixxQ0FBcUM7SUFDckMsTUFBTUMsV0FBVyxJQUFJRCxRQUFRUixNQUFNLEdBQUc7SUFDdEMseUNBQXlDO0lBQ3pDLG1EQUFtRDtJQUNuRCxPQUFPLElBQUlVLFdBQVc7UUFBRTNCLDBEQUFNQSxDQUFDeUIsUUFBUSxDQUFDLEVBQUUsSUFBSUMsWUFBYUE7S0FBUztBQUN4RTtBQUNBLFNBQVNFLFNBQVNwQixRQUFRO0lBQ3RCLElBQUksQ0FBQ3FCLE1BQU1DLE9BQU8sQ0FBQ3RCLGFBQWFBLFNBQVNTLE1BQU0sS0FBSyxRQUFRLE9BQU9ULFFBQVEsQ0FBQyxFQUFFLEtBQUssVUFDL0UsTUFBTSxJQUFJVSxNQUFNO0lBQ3BCVixTQUFTdUIsT0FBTyxDQUFDLENBQUNDO1FBQ2QsSUFBSSxPQUFPQSxNQUFNLFVBQ2IsTUFBTSxJQUFJZCxNQUFNLG1DQUFtQ2M7SUFDM0Q7SUFDQSxPQUFPMUIsOENBQVNBLENBQUMyQixLQUFLLENBQUMzQiw4Q0FBU0EsQ0FBQzRCLFFBQVEsQ0FBQyxHQUFHVixlQUFlbEIsOENBQVNBLENBQUM2QixNQUFNLENBQUMsSUFBSSxPQUFPN0IsOENBQVNBLENBQUM4QixRQUFRLENBQUM1QjtBQUMvRztBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVM2QixrQkFBa0JDLFFBQVEsRUFBRTlCLFFBQVE7SUFDaEQsTUFBTSxFQUFFTSxLQUFLLEVBQUUsR0FBR0YsVUFBVTBCO0lBQzVCLE1BQU1iLFVBQVVHLFNBQVNwQixVQUFVK0IsTUFBTSxDQUFDekI7SUFDMUNLLFNBQVNNO0lBQ1QsT0FBT0E7QUFDWDtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLFNBQVNGLGtCQUFrQkUsT0FBTyxFQUFFakIsUUFBUTtJQUMvQ1csU0FBU007SUFDVCxNQUFNWCxRQUFRYyxTQUFTcEIsVUFBVWdDLE1BQU0sQ0FBQ2Y7SUFDeEMsT0FBT1gsTUFBTTJCLElBQUksQ0FBQ2xDLFdBQVdDLFlBQVksTUFBVztBQUN4RDtBQUNBOztDQUVDLEdBQ00sU0FBU2tDLGlCQUFpQkosUUFBUSxFQUFFOUIsUUFBUTtJQUMvQyxJQUFJO1FBQ0E2QixrQkFBa0JDLFVBQVU5QjtJQUNoQyxFQUNBLE9BQU9tQyxHQUFHO1FBQ04sT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsTUFBTUMsUUFBUSxDQUFDQyxhQUFlcEMsS0FBSyxhQUFhb0M7QUFDaEQ7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU0MsZUFBZVIsUUFBUSxFQUFFTyxhQUFhLEVBQUU7SUFDcEQsT0FBTzlDLGlFQUFXQSxDQUFDRSxzREFBTUEsRUFBRVcsVUFBVTBCLFVBQVU3QixJQUFJLEVBQUVtQyxNQUFNQyxhQUFhO1FBQUVFLEdBQUc7UUFBTUMsT0FBTztJQUFHO0FBQ2pHO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU0MsbUJBQW1CWCxRQUFRLEVBQUVPLGFBQWEsRUFBRTtJQUN4RCxPQUFPL0MsNERBQU1BLENBQUNHLHNEQUFNQSxFQUFFVyxVQUFVMEIsVUFBVTdCLElBQUksRUFBRW1DLE1BQU1DLGFBQWE7UUFBRUUsR0FBRztRQUFNQyxPQUFPO0lBQUc7QUFDNUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub2NvZGUtbG1zLWJ1aWxkZXIvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2VzbS9pbmRleC5qcz81MmEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXVkaXRlZCAmIG1pbmltYWwgSlMgaW1wbGVtZW50YXRpb24gb2ZcbiAqIFtCSVAzOSBtbmVtb25pYyBwaHJhc2VzXShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDM5Lm1lZGlhd2lraSkuXG4gKiBAbW9kdWxlXG4gKiBAZXhhbXBsZVxuYGBganNcbmltcG9ydCAqIGFzIGJpcDM5IGZyb20gJ0BzY3VyZS9iaXAzOSc7XG5pbXBvcnQgeyB3b3JkbGlzdCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvZW5nbGlzaCc7XG5jb25zdCBtbiA9IGJpcDM5LmdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QpO1xuY29uc29sZS5sb2cobW4pO1xuY29uc3QgZW50ID0gYmlwMzkubW5lbW9uaWNUb0VudHJvcHkobW4sIHdvcmRsaXN0KVxuYmlwMzkuZW50cm9weVRvTW5lbW9uaWMoZW50LCB3b3JkbGlzdCk7XG5iaXAzOS52YWxpZGF0ZU1uZW1vbmljKG1uLCB3b3JkbGlzdCk7XG5hd2FpdCBiaXAzOS5tbmVtb25pY1RvU2VlZChtbiwgJ3Bhc3N3b3JkJyk7XG5iaXAzOS5tbmVtb25pY1RvU2VlZFN5bmMobW4sICdwYXNzd29yZCcpO1xuXG4vLyBXb3JkbGlzdHNcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGN6ZWNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9jemVjaCc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBlbmdsaXNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9lbmdsaXNoJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGZyZW5jaCB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvZnJlbmNoJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGl0YWxpYW4gfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2l0YWxpYW4nO1xuaW1wb3J0IHsgd29yZGxpc3QgYXMgamFwYW5lc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL2phcGFuZXNlJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIGtvcmVhbiB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMva29yZWFuJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIHBvcnR1Z3Vlc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL3BvcnR1Z3Vlc2UnO1xuaW1wb3J0IHsgd29yZGxpc3QgYXMgc2ltcGxpZmllZENoaW5lc2UgfSBmcm9tICdAc2N1cmUvYmlwMzkvd29yZGxpc3RzL3NpbXBsaWZpZWQtY2hpbmVzZSc7XG5pbXBvcnQgeyB3b3JkbGlzdCBhcyBzcGFuaXNoIH0gZnJvbSAnQHNjdXJlL2JpcDM5L3dvcmRsaXN0cy9zcGFuaXNoJztcbmltcG9ydCB7IHdvcmRsaXN0IGFzIHRyYWRpdGlvbmFsQ2hpbmVzZSB9IGZyb20gJ0BzY3VyZS9iaXAzOS93b3JkbGlzdHMvdHJhZGl0aW9uYWwtY2hpbmVzZSc7XG5gYGBcbiAqL1xuLyohIHNjdXJlLWJpcDM5IC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF0cmljaW8gUGFsbGFkaW5vLCBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHBia2RmMiwgcGJrZGYyQXN5bmMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3Bia2RmMic7XG5pbXBvcnQgeyBzaGEyNTYsIHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgeyBhYnl0ZXMsIGFudW1iZXIsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB1dGlscyBhcyBiYXNlVXRpbHMgfSBmcm9tICdAc2N1cmUvYmFzZSc7XG4vLyBKYXBhbmVzZSB3b3JkbGlzdFxuY29uc3QgaXNKYXBhbmVzZSA9ICh3b3JkbGlzdCkgPT4gd29yZGxpc3RbMF0gPT09ICdcXHUzMDQyXFx1MzA0NFxcdTMwNTNcXHUzMDRmXFx1MzA1N1xcdTMwOTMnO1xuLy8gTm9ybWFsaXphdGlvbiByZXBsYWNlcyBlcXVpdmFsZW50IHNlcXVlbmNlcyBvZiBjaGFyYWN0ZXJzXG4vLyBzbyB0aGF0IGFueSB0d28gdGV4dHMgdGhhdCBhcmUgZXF1aXZhbGVudCB3aWxsIGJlIHJlZHVjZWRcbi8vIHRvIHRoZSBzYW1lIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzLCBjYWxsZWQgdGhlIG5vcm1hbCBmb3JtIG9mIHRoZSBvcmlnaW5hbCB0ZXh0LlxuLy8gaHR0cHM6Ly90b25za3kubWUvYmxvZy91bmljb2RlLyN3aHktaXMtYS0tLS1cbmZ1bmN0aW9uIG5ma2Qoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG1uZW1vbmljIHR5cGU6ICcgKyB0eXBlb2Ygc3RyKTtcbiAgICByZXR1cm4gc3RyLm5vcm1hbGl6ZSgnTkZLRCcpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHN0cikge1xuICAgIGNvbnN0IG5vcm0gPSBuZmtkKHN0cik7XG4gICAgY29uc3Qgd29yZHMgPSBub3JtLnNwbGl0KCcgJyk7XG4gICAgaWYgKCFbMTIsIDE1LCAxOCwgMjEsIDI0XS5pbmNsdWRlcyh3b3Jkcy5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW5lbW9uaWMnKTtcbiAgICByZXR1cm4geyBuZmtkOiBub3JtLCB3b3JkcyB9O1xufVxuZnVuY3Rpb24gYWVudHJvcHkoZW50KSB7XG4gICAgYWJ5dGVzKGVudCwgMTYsIDIwLCAyNCwgMjgsIDMyKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgeCByYW5kb20gd29yZHMuIFVzZXMgQ3J5cHRvZ3JhcGhpY2FsbHktU2VjdXJlIFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yLlxuICogQHBhcmFtIHdvcmRsaXN0IGltcG9ydGVkIHdvcmRsaXN0IGZvciBzcGVjaWZpYyBsYW5ndWFnZVxuICogQHBhcmFtIHN0cmVuZ3RoIG1uZW1vbmljIHN0cmVuZ3RoIDEyOC0yNTYgYml0c1xuICogQGV4YW1wbGVcbiAqIGdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QsIDEyOClcbiAqIC8vICdsZWdhbCB3aW5uZXIgdGhhbmsgeWVhciB3YXZlIHNhdXNhZ2Ugd29ydGggdXNlZnVsIGxlZ2FsIHdpbm5lciB0aGFuayB5ZWxsb3cnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0LCBzdHJlbmd0aCA9IDEyOCkge1xuICAgIGFudW1iZXIoc3RyZW5ndGgpO1xuICAgIGlmIChzdHJlbmd0aCAlIDMyICE9PSAwIHx8IHN0cmVuZ3RoID4gMjU2KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGVudHJvcHknKTtcbiAgICByZXR1cm4gZW50cm9weVRvTW5lbW9uaWMocmFuZG9tQnl0ZXMoc3RyZW5ndGggLyA4KSwgd29yZGxpc3QpO1xufVxuY29uc3QgY2FsY0NoZWNrc3VtID0gKGVudHJvcHkpID0+IHtcbiAgICAvLyBDaGVja3N1bSBpcyBlbnQubGVuZ3RoLzQgYml0cyBsb25nXG4gICAgY29uc3QgYml0c0xlZnQgPSA4IC0gZW50cm9weS5sZW5ndGggLyA0O1xuICAgIC8vIFplcm8gcmlnaHRtb3N0IFwiYml0c0xlZnRcIiBiaXRzIGluIGJ5dGVcbiAgICAvLyBGb3IgZXhhbXBsZTogYml0c0xlZnQ9NCB2YWw9MTAxMTExMDEgLT4gMTAxMTAwMDBcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhzaGEyNTYoZW50cm9weSlbMF0gPj4gYml0c0xlZnQpIDw8IGJpdHNMZWZ0XSk7XG59O1xuZnVuY3Rpb24gZ2V0Q29kZXIod29yZGxpc3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZGxpc3QpIHx8IHdvcmRsaXN0Lmxlbmd0aCAhPT0gMjA0OCB8fCB0eXBlb2Ygd29yZGxpc3RbMF0gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmRsaXN0OiBleHBlY3RlZCBhcnJheSBvZiAyMDQ4IHN0cmluZ3MnKTtcbiAgICB3b3JkbGlzdC5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmRsaXN0OiBub24tc3RyaW5nIGVsZW1lbnQ6ICcgKyBpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmFzZVV0aWxzLmNoYWluKGJhc2VVdGlscy5jaGVja3N1bSgxLCBjYWxjQ2hlY2tzdW0pLCBiYXNlVXRpbHMucmFkaXgyKDExLCB0cnVlKSwgYmFzZVV0aWxzLmFscGhhYmV0KHdvcmRsaXN0KSk7XG59XG4vKipcbiAqIFJldmVyc2libGU6IENvbnZlcnRzIG1uZW1vbmljIHN0cmluZyB0byByYXcgZW50cm9weSBpbiBmb3JtIG9mIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0gbW5lbW9uaWMgMTItMjQgd29yZHNcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtbmVtID0gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdyc7XG4gKiBtbmVtb25pY1RvRW50cm9weShtbmVtLCB3b3JkbGlzdClcbiAqIC8vIFByb2R1Y2VzXG4gKiBuZXcgVWludDhBcnJheShbXG4gKiAgIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsXG4gKiAgIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2YsIDB4N2ZcbiAqIF0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBub3JtYWxpemUobW5lbW9uaWMpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZGVjb2RlKHdvcmRzKTtcbiAgICBhZW50cm9weShlbnRyb3B5KTtcbiAgICByZXR1cm4gZW50cm9weTtcbn1cbi8qKlxuICogUmV2ZXJzaWJsZTogQ29udmVydHMgcmF3IGVudHJvcHkgaW4gZm9ybSBvZiBieXRlIGFycmF5IHRvIG1uZW1vbmljIHN0cmluZy5cbiAqIEBwYXJhbSBlbnRyb3B5IGJ5dGUgYXJyYXlcbiAqIEBwYXJhbSB3b3JkbGlzdCBpbXBvcnRlZCB3b3JkbGlzdCBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2VcbiAqIEByZXR1cm5zIDEyLTI0IHdvcmRzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZW50ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLFxuICogICAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmLCAweDdmXG4gKiBdKTtcbiAqIGVudHJvcHlUb01uZW1vbmljKGVudCwgd29yZGxpc3QpO1xuICogLy8gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgYWVudHJvcHkoZW50cm9weSk7XG4gICAgY29uc3Qgd29yZHMgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZW5jb2RlKGVudHJvcHkpO1xuICAgIHJldHVybiB3b3Jkcy5qb2luKGlzSmFwYW5lc2Uod29yZGxpc3QpID8gJ1xcdTMwMDAnIDogJyAnKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIG1uZW1vbmljIGZvciBiZWluZyAxMi0yNCB3b3JkcyBjb250YWluZWQgaW4gYHdvcmRsaXN0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IHBzYWx0ID0gKHBhc3NwaHJhc2UpID0+IG5ma2QoJ21uZW1vbmljJyArIHBhc3NwaHJhc2UpO1xuLyoqXG4gKiBJcnJldmVyc2libGU6IFVzZXMgS0RGIHRvIGRlcml2ZSA2NCBieXRlcyBvZiBrZXkgZGF0YSBmcm9tIG1uZW1vbmljICsgb3B0aW9uYWwgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbW5lbW9uaWMgMTItMjQgd29yZHNcbiAqIEBwYXJhbSBwYXNzcGhyYXNlIHN0cmluZyB0aGF0IHdpbGwgYWRkaXRpb25hbGx5IHByb3RlY3QgdGhlIGtleVxuICogQHJldHVybnMgNjQgYnl0ZXMgb2Yga2V5IGRhdGFcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtbmVtID0gJ2xlZ2FsIHdpbm5lciB0aGFuayB5ZWFyIHdhdmUgc2F1c2FnZSB3b3J0aCB1c2VmdWwgbGVnYWwgd2lubmVyIHRoYW5rIHllbGxvdyc7XG4gKiBhd2FpdCBtbmVtb25pY1RvU2VlZChtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvU2VlZChtbmVtb25pYywgcGFzc3BocmFzZSA9ICcnKSB7XG4gICAgcmV0dXJuIHBia2RmMkFzeW5jKHNoYTUxMiwgbm9ybWFsaXplKG1uZW1vbmljKS5uZmtkLCBwc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG4vKipcbiAqIElycmV2ZXJzaWJsZTogVXNlcyBLREYgdG8gZGVyaXZlIDY0IGJ5dGVzIG9mIGtleSBkYXRhIGZyb20gbW5lbW9uaWMgKyBvcHRpb25hbCBwYXNzd29yZC5cbiAqIEBwYXJhbSBtbmVtb25pYyAxMi0yNCB3b3Jkc1xuICogQHBhcmFtIHBhc3NwaHJhc2Ugc3RyaW5nIHRoYXQgd2lsbCBhZGRpdGlvbmFsbHkgcHJvdGVjdCB0aGUga2V5XG4gKiBAcmV0dXJucyA2NCBieXRlcyBvZiBrZXkgZGF0YVxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1uZW0gPSAnbGVnYWwgd2lubmVyIHRoYW5rIHllYXIgd2F2ZSBzYXVzYWdlIHdvcnRoIHVzZWZ1bCBsZWdhbCB3aW5uZXIgdGhhbmsgeWVsbG93JztcbiAqIG1uZW1vbmljVG9TZWVkU3luYyhtbmVtLCAncGFzc3dvcmQnKTtcbiAqIC8vIG5ldyBVaW50OEFycmF5KFsuLi42NCBieXRlc10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvU2VlZFN5bmMobW5lbW9uaWMsIHBhc3NwaHJhc2UgPSAnJykge1xuICAgIHJldHVybiBwYmtkZjIoc2hhNTEyLCBub3JtYWxpemUobW5lbW9uaWMpLm5ma2QsIHBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbiJdLCJuYW1lcyI6WyJwYmtkZjIiLCJwYmtkZjJBc3luYyIsInNoYTI1NiIsInNoYTUxMiIsImFieXRlcyIsImFudW1iZXIiLCJyYW5kb21CeXRlcyIsInV0aWxzIiwiYmFzZVV0aWxzIiwiaXNKYXBhbmVzZSIsIndvcmRsaXN0IiwibmZrZCIsInN0ciIsIlR5cGVFcnJvciIsIm5vcm1hbGl6ZSIsIm5vcm0iLCJ3b3JkcyIsInNwbGl0IiwiaW5jbHVkZXMiLCJsZW5ndGgiLCJFcnJvciIsImFlbnRyb3B5IiwiZW50IiwiZ2VuZXJhdGVNbmVtb25pYyIsInN0cmVuZ3RoIiwiZW50cm9weVRvTW5lbW9uaWMiLCJjYWxjQ2hlY2tzdW0iLCJlbnRyb3B5IiwiYml0c0xlZnQiLCJVaW50OEFycmF5IiwiZ2V0Q29kZXIiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwiaSIsImNoYWluIiwiY2hlY2tzdW0iLCJyYWRpeDIiLCJhbHBoYWJldCIsIm1uZW1vbmljVG9FbnRyb3B5IiwibW5lbW9uaWMiLCJkZWNvZGUiLCJlbmNvZGUiLCJqb2luIiwidmFsaWRhdGVNbmVtb25pYyIsImUiLCJwc2FsdCIsInBhc3NwaHJhc2UiLCJtbmVtb25pY1RvU2VlZCIsImMiLCJka0xlbiIsIm1uZW1vbmljVG9TZWVkU3luYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/esm/index.js\n");

/***/ })

};
;