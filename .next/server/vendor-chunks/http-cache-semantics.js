"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/http-cache-semantics";
exports.ids = ["vendor-chunks/http-cache-semantics"];
exports.modules = {

/***/ "(ssr)/./node_modules/http-cache-semantics/index.js":
/*!****************************************************!*\
  !*** ./node_modules/http-cache-semantics/index.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\n/**\n * @typedef {Object} HttpRequest\n * @property {Record<string, string>} headers - Request headers\n * @property {string} [method] - HTTP method\n * @property {string} [url] - Request URL\n */ /**\n * @typedef {Object} HttpResponse\n * @property {Record<string, string>} headers - Response headers\n * @property {number} [status] - HTTP status code\n */ /**\n * Set of default cacheable status codes per RFC 7231 section 6.1.\n * @type {Set<number>}\n */ const statusCodeCacheableByDefault = new Set([\n    200,\n    203,\n    204,\n    206,\n    300,\n    301,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501\n]);\n/**\n * Set of HTTP status codes that the cache implementation understands.\n * Note: This implementation does not understand partial responses (206).\n * @type {Set<number>}\n */ const understoodStatuses = new Set([\n    200,\n    203,\n    204,\n    300,\n    301,\n    302,\n    303,\n    307,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501\n]);\n/**\n * Set of HTTP error status codes.\n * @type {Set<number>}\n */ const errorStatusCodes = new Set([\n    500,\n    502,\n    503,\n    504\n]);\n/**\n * Object representing hop-by-hop headers that should be removed.\n * @type {Record<string, boolean>}\n */ const hopByHopHeaders = {\n    date: true,\n    connection: true,\n    \"keep-alive\": true,\n    \"proxy-authenticate\": true,\n    \"proxy-authorization\": true,\n    te: true,\n    trailer: true,\n    \"transfer-encoding\": true,\n    upgrade: true\n};\n/**\n * Headers that are excluded from revalidation update.\n * @type {Record<string, boolean>}\n */ const excludedFromRevalidationUpdate = {\n    // Since the old body is reused, it doesn't make sense to change properties of the body\n    \"content-length\": true,\n    \"content-encoding\": true,\n    \"transfer-encoding\": true,\n    \"content-range\": true\n};\n/**\n * Converts a string to a number or returns zero if the conversion fails.\n * @param {string} s - The string to convert.\n * @returns {number} The parsed number or 0.\n */ function toNumberOrZero(s) {\n    const n = parseInt(s, 10);\n    return isFinite(n) ? n : 0;\n}\n/**\n * Determines if the given response is an error response.\n * Implements RFC 5861 behavior.\n * @param {HttpResponse|undefined} response - The HTTP response object.\n * @returns {boolean} true if the response is an error or undefined, false otherwise.\n */ function isErrorResponse(response) {\n    // consider undefined response as faulty\n    if (!response) {\n        return true;\n    }\n    return errorStatusCodes.has(response.status);\n}\n/**\n * Parses a Cache-Control header string into an object.\n * @param {string} [header] - The Cache-Control header value.\n * @returns {Record<string, string|boolean>} An object representing Cache-Control directives.\n */ function parseCacheControl(header) {\n    /** @type {Record<string, string|boolean>} */ const cc = {};\n    if (!header) return cc;\n    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n    const parts = header.trim().split(/,/);\n    for (const part of parts){\n        const [k, v] = part.split(/=/, 2);\n        cc[k.trim()] = v === undefined ? true : v.trim().replace(/^\"|\"$/g, \"\");\n    }\n    return cc;\n}\n/**\n * Formats a Cache-Control directives object into a header string.\n * @param {Record<string, string|boolean>} cc - The Cache-Control directives.\n * @returns {string|undefined} A formatted Cache-Control header string or undefined if empty.\n */ function formatCacheControl(cc) {\n    let parts = [];\n    for(const k in cc){\n        const v = cc[k];\n        parts.push(v === true ? k : k + \"=\" + v);\n    }\n    if (!parts.length) {\n        return undefined;\n    }\n    return parts.join(\", \");\n}\nmodule.exports = class CachePolicy {\n    /**\n     * Creates a new CachePolicy instance.\n     * @param {HttpRequest} req - Incoming client request.\n     * @param {HttpResponse} res - Received server response.\n     * @param {Object} [options={}] - Configuration options.\n     * @param {boolean} [options.shared=true] - Is the cache shared (a public proxy)? `false` for personal browser caches.\n     * @param {number} [options.cacheHeuristic=0.1] - Fallback heuristic (age fraction) for cache duration.\n     * @param {number} [options.immutableMinTimeToLive=86400000] - Minimum TTL for immutable responses in milliseconds.\n     * @param {boolean} [options.ignoreCargoCult=false] - Detect nonsense cache headers, and override them.\n     * @param {any} [options._fromObject] - Internal parameter for deserialization. Do not use.\n     */ constructor(req, res, { shared, cacheHeuristic, immutableMinTimeToLive, ignoreCargoCult, _fromObject } = {}){\n        if (_fromObject) {\n            this._fromObject(_fromObject);\n            return;\n        }\n        if (!res || !res.headers) {\n            throw Error(\"Response headers missing\");\n        }\n        this._assertRequestHasHeaders(req);\n        /** @type {number} Timestamp when the response was received */ this._responseTime = this.now();\n        /** @type {boolean} Indicates if the cache is shared */ this._isShared = shared !== false;\n        /** @type {boolean} Indicates if legacy cargo cult directives should be ignored */ this._ignoreCargoCult = !!ignoreCargoCult;\n        /** @type {number} Heuristic cache fraction */ this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n        /** @type {number} Minimum TTL for immutable responses in ms */ this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;\n        /** @type {number} HTTP status code */ this._status = \"status\" in res ? res.status : 200;\n        /** @type {Record<string, string>} Response headers */ this._resHeaders = res.headers;\n        /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from response */ this._rescc = parseCacheControl(res.headers[\"cache-control\"]);\n        /** @type {string} HTTP method (e.g., GET, POST) */ this._method = \"method\" in req ? req.method : \"GET\";\n        /** @type {string} Request URL */ this._url = req.url;\n        /** @type {string} Host header from the request */ this._host = req.headers.host;\n        /** @type {boolean} Whether the request does not include an Authorization header */ this._noAuthorization = !req.headers.authorization;\n        /** @type {Record<string, string>|null} Request headers used for Vary matching */ this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n        /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from request */ this._reqcc = parseCacheControl(req.headers[\"cache-control\"]);\n        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n        // so there's no point stricly adhering to the blindly copy&pasted directives.\n        if (this._ignoreCargoCult && \"pre-check\" in this._rescc && \"post-check\" in this._rescc) {\n            delete this._rescc[\"pre-check\"];\n            delete this._rescc[\"post-check\"];\n            delete this._rescc[\"no-cache\"];\n            delete this._rescc[\"no-store\"];\n            delete this._rescc[\"must-revalidate\"];\n            this._resHeaders = Object.assign({}, this._resHeaders, {\n                \"cache-control\": formatCacheControl(this._rescc)\n            });\n            delete this._resHeaders.expires;\n            delete this._resHeaders.pragma;\n        }\n        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n        // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n        if (res.headers[\"cache-control\"] == null && /no-cache/.test(res.headers.pragma)) {\n            this._rescc[\"no-cache\"] = true;\n        }\n    }\n    /**\n     * You can monkey-patch it for testing.\n     * @returns {number} Current time in milliseconds.\n     */ now() {\n        return Date.now();\n    }\n    /**\n     * Determines if the response is storable in a cache.\n     * @returns {boolean} `false` if can never be cached.\n     */ storable() {\n        // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n        return !!(!this._reqcc[\"no-store\"] && // A cache MUST NOT store a response to any request, unless:\n        // The request method is understood by the cache and defined as being cacheable, and\n        (\"GET\" === this._method || \"HEAD\" === this._method || \"POST\" === this._method && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and\n        understoodStatuses.has(this._status) && // the \"no-store\" cache directive does not appear in request or response header fields, and\n        !this._rescc[\"no-store\"] && // the \"private\" response directive does not appear in the response, if the cache is shared, and\n        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,\n        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:\n        // contains an Expires header field, or\n        (this._resHeaders.expires || // contains a max-age response directive, or\n        // contains a s-maxage response directive and the cache is shared, or\n        // contains a public response directive.\n        this._rescc[\"max-age\"] || this._isShared && this._rescc[\"s-maxage\"] || this._rescc.public || // has a status code that is defined as cacheable by default\n        statusCodeCacheableByDefault.has(this._status)));\n    }\n    /**\n     * @returns {boolean} true if expiration is explicitly defined.\n     */ _hasExplicitExpiration() {\n        // 4.2.1 Calculating Freshness Lifetime\n        return !!(this._isShared && this._rescc[\"s-maxage\"] || this._rescc[\"max-age\"] || this._resHeaders.expires);\n    }\n    /**\n     * @param {HttpRequest} req - a request\n     * @throws {Error} if the headers are missing.\n     */ _assertRequestHasHeaders(req) {\n        if (!req || !req.headers) {\n            throw Error(\"Request headers missing\");\n        }\n    }\n    /**\n     * Checks if the request matches the cache and can be satisfied from the cache immediately,\n     * without having to make a request to the server.\n     *\n     * This doesn't support `stale-while-revalidate`. See `evaluateRequest()` for a more complete solution.\n     *\n     * @param {HttpRequest} req - The new incoming HTTP request.\n     * @returns {boolean} `true`` if the cached response used to construct this cache policy satisfies the request without revalidation.\n     */ satisfiesWithoutRevalidation(req) {\n        const result = this.evaluateRequest(req);\n        return !result.revalidation;\n    }\n    /**\n     * @param {{headers: Record<string, string>, synchronous: boolean}|undefined} revalidation - Revalidation information, if any.\n     * @returns {{response: {headers: Record<string, string>}, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object with a cached response headers and revalidation info.\n     */ _evaluateRequestHitResult(revalidation) {\n        return {\n            response: {\n                headers: this.responseHeaders()\n            },\n            revalidation\n        };\n    }\n    /**\n     * @param {HttpRequest} request - new incoming\n     * @param {boolean} synchronous - whether revalidation must be synchronous (not s-w-r).\n     * @returns {{headers: Record<string, string>, synchronous: boolean}} An object with revalidation headers and a synchronous flag.\n     */ _evaluateRequestRevalidation(request, synchronous) {\n        return {\n            synchronous,\n            headers: this.revalidationHeaders(request)\n        };\n    }\n    /**\n     * @param {HttpRequest} request - new incoming\n     * @returns {{response: undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}}} An object indicating no cached response and revalidation details.\n     */ _evaluateRequestMissResult(request) {\n        return {\n            response: undefined,\n            revalidation: this._evaluateRequestRevalidation(request, true)\n        };\n    }\n    /**\n     * Checks if the given request matches this cache entry, and how the cache can be used to satisfy it. Returns an object with:\n     *\n     * ```\n     * {\n     *     // If defined, you must send a request to the server.\n     *     revalidation: {\n     *         headers: {}, // HTTP headers to use when sending the revalidation response\n     *         // If true, you MUST wait for a response from the server before using the cache\n     *         // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.\n     *         synchronous: bool,\n     *     },\n     *     // If defined, you can use this cached response.\n     *     response: {\n     *         headers: {}, // Updated cached HTTP headers you must use when responding to the client\n     *     },\n     * }\n     * ```\n     * @param {HttpRequest} req - new incoming HTTP request\n     * @returns {{response: {headers: Record<string, string>}|undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object containing keys:\n     *   - revalidation: { headers: Record<string, string>, synchronous: boolean } Set if you should send this to the origin server\n     *   - response: { headers: Record<string, string> } Set if you can respond to the client with these cached headers\n     */ evaluateRequest(req) {\n        this._assertRequestHasHeaders(req);\n        // In all circumstances, a cache MUST NOT ignore the must-revalidate directive\n        if (this._rescc[\"must-revalidate\"]) {\n            return this._evaluateRequestMissResult(req);\n        }\n        if (!this._requestMatches(req, false)) {\n            return this._evaluateRequestMissResult(req);\n        }\n        // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n        // unless the stored response is successfully validated (Section 4.3), and\n        const requestCC = parseCacheControl(req.headers[\"cache-control\"]);\n        if (requestCC[\"no-cache\"] || /no-cache/.test(req.headers.pragma)) {\n            return this._evaluateRequestMissResult(req);\n        }\n        if (requestCC[\"max-age\"] && this.age() > toNumberOrZero(requestCC[\"max-age\"])) {\n            return this._evaluateRequestMissResult(req);\n        }\n        if (requestCC[\"min-fresh\"] && this.maxAge() - this.age() < toNumberOrZero(requestCC[\"min-fresh\"])) {\n            return this._evaluateRequestMissResult(req);\n        }\n        // the stored response is either:\n        // fresh, or allowed to be served stale\n        if (this.stale()) {\n            // If a value is present, then the client is willing to accept a response that has\n            // exceeded its freshness lifetime by no more than the specified number of seconds\n            const allowsStaleWithoutRevalidation = \"max-stale\" in requestCC && (true === requestCC[\"max-stale\"] || requestCC[\"max-stale\"] > this.age() - this.maxAge());\n            if (allowsStaleWithoutRevalidation) {\n                return this._evaluateRequestHitResult(undefined);\n            }\n            if (this.useStaleWhileRevalidate()) {\n                return this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, false));\n            }\n            return this._evaluateRequestMissResult(req);\n        }\n        return this._evaluateRequestHitResult(undefined);\n    }\n    /**\n     * @param {HttpRequest} req - check if this is for the same cache entry\n     * @param {boolean} allowHeadMethod - allow a HEAD method to match.\n     * @returns {boolean} `true` if the request matches.\n     */ _requestMatches(req, allowHeadMethod) {\n        // The presented effective request URI and that of the stored response match, and\n        return !!((!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and\n        (!req.method || this._method === req.method || allowHeadMethod && \"HEAD\" === req.method) && // selecting header fields nominated by the stored response (if any) match those presented, and\n        this._varyMatches(req));\n    }\n    /**\n     * Determines whether storing authenticated responses is allowed.\n     * @returns {boolean} `true` if allowed.\n     */ _allowsStoringAuthenticated() {\n        // following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n        return !!(this._rescc[\"must-revalidate\"] || this._rescc.public || this._rescc[\"s-maxage\"]);\n    }\n    /**\n     * Checks whether the Vary header in the response matches the new request.\n     * @param {HttpRequest} req - incoming HTTP request\n     * @returns {boolean} `true` if the vary headers match.\n     */ _varyMatches(req) {\n        if (!this._resHeaders.vary) {\n            return true;\n        }\n        // A Vary header field-value of \"*\" always fails to match\n        if (this._resHeaders.vary === \"*\") {\n            return false;\n        }\n        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n        for (const name of fields){\n            if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n        return true;\n    }\n    /**\n     * Creates a copy of the given headers without any hop-by-hop headers.\n     * @param {Record<string, string>} inHeaders - old headers from the cached response\n     * @returns {Record<string, string>} A new headers object without hop-by-hop headers.\n     */ _copyWithoutHopByHopHeaders(inHeaders) {\n        /** @type {Record<string, string>} */ const headers = {};\n        for(const name in inHeaders){\n            if (hopByHopHeaders[name]) continue;\n            headers[name] = inHeaders[name];\n        }\n        // 9.1.  Connection\n        if (inHeaders.connection) {\n            const tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n            for (const name of tokens){\n                delete headers[name];\n            }\n        }\n        if (headers.warning) {\n            const warnings = headers.warning.split(/,/).filter((warning)=>{\n                return !/^\\s*1[0-9][0-9]/.test(warning);\n            });\n            if (!warnings.length) {\n                delete headers.warning;\n            } else {\n                headers.warning = warnings.join(\",\").trim();\n            }\n        }\n        return headers;\n    }\n    /**\n     * Returns the response headers adjusted for serving the cached response.\n     * Removes hop-by-hop headers and updates the Age and Date headers.\n     * @returns {Record<string, string>} The adjusted response headers.\n     */ responseHeaders() {\n        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n        const age = this.age();\n        // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n        // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {\n            headers.warning = (headers.warning ? `${headers.warning}, ` : \"\") + '113 - \"rfc7234 5.5.4\"';\n        }\n        headers.age = `${Math.round(age)}`;\n        headers.date = new Date(this.now()).toUTCString();\n        return headers;\n    }\n    /**\n     * Returns the Date header value from the response or the current time if invalid.\n     * @returns {number} Timestamp (in milliseconds) representing the Date header or response time.\n     */ date() {\n        const serverDate = Date.parse(this._resHeaders.date);\n        if (isFinite(serverDate)) {\n            return serverDate;\n        }\n        return this._responseTime;\n    }\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     * @returns {number} The age in seconds.\n     */ age() {\n        let age = this._ageValue();\n        const residentTime = (this.now() - this._responseTime) / 1000;\n        return age + residentTime;\n    }\n    /**\n     * @returns {number} The Age header value as a number.\n     */ _ageValue() {\n        return toNumberOrZero(this._resHeaders.age);\n    }\n    /**\n     * Possibly outdated value of applicable max-age (or heuristic equivalent) in seconds.\n     * This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * Returns the maximum age (freshness lifetime) of the response in seconds.\n     * @returns {number} The max-age value in seconds.\n     */ maxAge() {\n        if (!this.storable() || this._rescc[\"no-cache\"]) {\n            return 0;\n        }\n        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n        // so this implementation requires explicit opt-in via public header\n        if (this._isShared && this._resHeaders[\"set-cookie\"] && !this._rescc.public && !this._rescc.immutable) {\n            return 0;\n        }\n        if (this._resHeaders.vary === \"*\") {\n            return 0;\n        }\n        if (this._isShared) {\n            if (this._rescc[\"proxy-revalidate\"]) {\n                return 0;\n            }\n            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n            if (this._rescc[\"s-maxage\"]) {\n                return toNumberOrZero(this._rescc[\"s-maxage\"]);\n            }\n        }\n        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n        if (this._rescc[\"max-age\"]) {\n            return toNumberOrZero(this._rescc[\"max-age\"]);\n        }\n        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n        const serverDate = this.date();\n        if (this._resHeaders.expires) {\n            const expires = Date.parse(this._resHeaders.expires);\n            // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n            if (Number.isNaN(expires) || expires < serverDate) {\n                return 0;\n            }\n            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n        }\n        if (this._resHeaders[\"last-modified\"]) {\n            const lastModified = Date.parse(this._resHeaders[\"last-modified\"]);\n            if (isFinite(lastModified) && serverDate > lastModified) {\n                return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);\n            }\n        }\n        return defaultMinTtl;\n    }\n    /**\n     * Remaining time this cache entry may be useful for, in *milliseconds*.\n     * You can use this as an expiration time for your cache storage.\n     *\n     * Prefer this method over `maxAge()`, because it includes other factors like `age` and `stale-while-revalidate`.\n     * @returns {number} Time-to-live in milliseconds.\n     */ timeToLive() {\n        const age = this.maxAge() - this.age();\n        const staleIfErrorAge = age + toNumberOrZero(this._rescc[\"stale-if-error\"]);\n        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc[\"stale-while-revalidate\"]);\n        return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000);\n    }\n    /**\n     * If true, this cache entry is past its expiration date.\n     * Note that stale cache may be useful sometimes, see `evaluateRequest()`.\n     * @returns {boolean} `false` doesn't mean it's fresh nor usable\n     */ stale() {\n        return this.maxAge() <= this.age();\n    }\n    /**\n     * @returns {boolean} `true` if `stale-if-error` condition allows use of a stale response.\n     */ _useStaleIfError() {\n        return this.maxAge() + toNumberOrZero(this._rescc[\"stale-if-error\"]) > this.age();\n    }\n    /** See `evaluateRequest()` for a more complete solution\n     * @returns {boolean} `true` if `stale-while-revalidate` is currently allowed.\n     */ useStaleWhileRevalidate() {\n        const swr = toNumberOrZero(this._rescc[\"stale-while-revalidate\"]);\n        return swr > 0 && this.maxAge() + swr > this.age();\n    }\n    /**\n     * Creates a `CachePolicy` instance from a serialized object.\n     * @param {Object} obj - The serialized object.\n     * @returns {CachePolicy} A new CachePolicy instance.\n     */ static fromObject(obj) {\n        return new this(undefined, undefined, {\n            _fromObject: obj\n        });\n    }\n    /**\n     * @param {any} obj - The serialized object.\n     * @throws {Error} If already initialized or if the object is invalid.\n     */ _fromObject(obj) {\n        if (this._responseTime) throw Error(\"Reinitialized\");\n        if (!obj || obj.v !== 1) throw Error(\"Invalid serialization\");\n        this._responseTime = obj.t;\n        this._isShared = obj.sh;\n        this._cacheHeuristic = obj.ch;\n        this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n        this._ignoreCargoCult = !!obj.icc;\n        this._status = obj.st;\n        this._resHeaders = obj.resh;\n        this._rescc = obj.rescc;\n        this._method = obj.m;\n        this._url = obj.u;\n        this._host = obj.h;\n        this._noAuthorization = obj.a;\n        this._reqHeaders = obj.reqh;\n        this._reqcc = obj.reqcc;\n    }\n    /**\n     * Serializes the `CachePolicy` instance into a JSON-serializable object.\n     * @returns {Object} The serialized object.\n     */ toObject() {\n        return {\n            v: 1,\n            t: this._responseTime,\n            sh: this._isShared,\n            ch: this._cacheHeuristic,\n            imm: this._immutableMinTtl,\n            icc: this._ignoreCargoCult,\n            st: this._status,\n            resh: this._resHeaders,\n            rescc: this._rescc,\n            m: this._method,\n            u: this._url,\n            h: this._host,\n            a: this._noAuthorization,\n            reqh: this._reqHeaders,\n            reqcc: this._reqcc\n        };\n    }\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     * @param {HttpRequest} incomingReq - The incoming HTTP request.\n     * @returns {Record<string, string>} The headers for the revalidation request.\n     */ revalidationHeaders(incomingReq) {\n        this._assertRequestHasHeaders(incomingReq);\n        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n        // This implementation does not understand range requests\n        delete headers[\"if-range\"];\n        if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n            // revalidation allowed via HEAD\n            // not for the same resource, or wasn't allowed to be cached anyway\n            delete headers[\"if-none-match\"];\n            delete headers[\"if-modified-since\"];\n            return headers;\n        }\n        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */ if (this._resHeaders.etag) {\n            headers[\"if-none-match\"] = headers[\"if-none-match\"] ? `${headers[\"if-none-match\"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;\n        }\n        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n        const forbidsWeakValidators = headers[\"accept-ranges\"] || headers[\"if-match\"] || headers[\"if-unmodified-since\"] || this._method && this._method != \"GET\";\n        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n        Note: This implementation does not understand partial responses (206) */ if (forbidsWeakValidators) {\n            delete headers[\"if-modified-since\"];\n            if (headers[\"if-none-match\"]) {\n                const etags = headers[\"if-none-match\"].split(/,/).filter((etag)=>{\n                    return !/^\\s*W\\//.test(etag);\n                });\n                if (!etags.length) {\n                    delete headers[\"if-none-match\"];\n                } else {\n                    headers[\"if-none-match\"] = etags.join(\",\").trim();\n                }\n            }\n        } else if (this._resHeaders[\"last-modified\"] && !headers[\"if-modified-since\"]) {\n            headers[\"if-modified-since\"] = this._resHeaders[\"last-modified\"];\n        }\n        return headers;\n    }\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @param {HttpRequest} request - The latest HTTP request asking for the cached entry.\n     * @param {HttpResponse} response - The latest revalidation HTTP response from the origin server.\n     * @returns {{policy: CachePolicy, modified: boolean, matches: boolean}} The updated policy and modification status.\n     * @throws {Error} If the response headers are missing.\n     */ revalidatedPolicy(request, response) {\n        this._assertRequestHasHeaders(request);\n        if (this._useStaleIfError() && isErrorResponse(response)) {\n            return {\n                policy: this,\n                modified: false,\n                matches: true\n            };\n        }\n        if (!response || !response.headers) {\n            throw Error(\"Response headers missing\");\n        }\n        // These aren't going to be supported exactly, since one CachePolicy object\n        // doesn't know about all the other cached objects.\n        let matches = false;\n        if (response.status !== undefined && response.status != 304) {\n            matches = false;\n        } else if (response.headers.etag && !/^\\s*W\\//.test(response.headers.etag)) {\n            // \"All of the stored responses with the same strong validator are selected.\n            // If none of the stored responses contain the same strong validator,\n            // then the cache MUST NOT use the new response to update any stored responses.\"\n            matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, \"\") === response.headers.etag;\n        } else if (this._resHeaders.etag && response.headers.etag) {\n            // \"If the new response contains a weak validator and that validator corresponds\n            // to one of the cache's stored responses,\n            // then the most recent of those matching stored responses is selected for update.\"\n            matches = this._resHeaders.etag.replace(/^\\s*W\\//, \"\") === response.headers.etag.replace(/^\\s*W\\//, \"\");\n        } else if (this._resHeaders[\"last-modified\"]) {\n            matches = this._resHeaders[\"last-modified\"] === response.headers[\"last-modified\"];\n        } else {\n            // If the new response does not include any form of validator (such as in the case where\n            // a client generates an If-Modified-Since request from a source other than the Last-Modified\n            // response header field), and there is only one stored response, and that stored response also\n            // lacks a validator, then that stored response is selected for update.\n            if (!this._resHeaders.etag && !this._resHeaders[\"last-modified\"] && !response.headers.etag && !response.headers[\"last-modified\"]) {\n                matches = true;\n            }\n        }\n        const optionsCopy = {\n            shared: this._isShared,\n            cacheHeuristic: this._cacheHeuristic,\n            immutableMinTimeToLive: this._immutableMinTtl,\n            ignoreCargoCult: this._ignoreCargoCult\n        };\n        if (!matches) {\n            return {\n                policy: new this.constructor(request, response, optionsCopy),\n                // Client receiving 304 without body, even if it's invalid/mismatched has no option\n                // but to reuse a cached body. We don't have a good way to tell clients to do\n                // error recovery in such case.\n                modified: response.status != 304,\n                matches: false\n            };\n        }\n        // use other header fields provided in the 304 (Not Modified) response to replace all instances\n        // of the corresponding header fields in the stored response.\n        const headers = {};\n        for(const k in this._resHeaders){\n            headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];\n        }\n        const newResponse = Object.assign({}, response, {\n            status: this._status,\n            method: this._method,\n            headers\n        });\n        return {\n            policy: new this.constructor(request, newResponse, optionsCopy),\n            modified: false,\n            matches: true\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHR0cC1jYWNoZS1zZW1hbnRpY3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQTs7Ozs7Q0FLQyxHQUVEOzs7O0NBSUMsR0FFRDs7O0NBR0MsR0FDRCxNQUFNQSwrQkFBK0IsSUFBSUMsSUFBSTtJQUN6QztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUVEOzs7O0NBSUMsR0FDRCxNQUFNQyxxQkFBcUIsSUFBSUQsSUFBSTtJQUMvQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFFRDs7O0NBR0MsR0FDRCxNQUFNRSxtQkFBbUIsSUFBSUYsSUFBSTtJQUM3QjtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBRUQ7OztDQUdDLEdBQ0QsTUFBTUcsa0JBQWtCO0lBQ3BCQyxNQUFNO0lBQ05DLFlBQVk7SUFDWixjQUFjO0lBQ2Qsc0JBQXNCO0lBQ3RCLHVCQUF1QjtJQUN2QkMsSUFBSTtJQUNKQyxTQUFTO0lBQ1QscUJBQXFCO0lBQ3JCQyxTQUFTO0FBQ2I7QUFFQTs7O0NBR0MsR0FDRCxNQUFNQyxpQ0FBaUM7SUFDbkMsdUZBQXVGO0lBQ3ZGLGtCQUFrQjtJQUNsQixvQkFBb0I7SUFDcEIscUJBQXFCO0lBQ3JCLGlCQUFpQjtBQUNyQjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTQyxlQUFlQyxDQUFDO0lBQ3JCLE1BQU1DLElBQUlDLFNBQVNGLEdBQUc7SUFDdEIsT0FBT0csU0FBU0YsS0FBS0EsSUFBSTtBQUM3QjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0csZ0JBQWdCQyxRQUFRO0lBQzdCLHdDQUF3QztJQUN4QyxJQUFJLENBQUNBLFVBQVU7UUFDWCxPQUFPO0lBQ1g7SUFDQSxPQUFPZCxpQkFBaUJlLEdBQUcsQ0FBQ0QsU0FBU0UsTUFBTTtBQUMvQztBQUVBOzs7O0NBSUMsR0FD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ZGUtbG1zLWJ1aWxkZXIvLi9ub2RlX21vZHVsZXMvaHR0cC1jYWNoZS1zZW1hbnRpY3MvaW5kZXguanM/Y2Q1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSHR0cFJlcXVlc3RcbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVycyAtIFJlcXVlc3QgaGVhZGVyc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFttZXRob2RdIC0gSFRUUCBtZXRob2RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSAtIFJlcXVlc3QgVVJMXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIdHRwUmVzcG9uc2VcbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVycyAtIFJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RhdHVzXSAtIEhUVFAgc3RhdHVzIGNvZGVcbiAqL1xuXG4vKipcbiAqIFNldCBvZiBkZWZhdWx0IGNhY2hlYWJsZSBzdGF0dXMgY29kZXMgcGVyIFJGQyA3MjMxIHNlY3Rpb24gNi4xLlxuICogQHR5cGUge1NldDxudW1iZXI+fVxuICovXG5jb25zdCBzdGF0dXNDb2RlQ2FjaGVhYmxlQnlEZWZhdWx0ID0gbmV3IFNldChbXG4gICAgMjAwLFxuICAgIDIwMyxcbiAgICAyMDQsXG4gICAgMjA2LFxuICAgIDMwMCxcbiAgICAzMDEsXG4gICAgMzA4LFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDEwLFxuICAgIDQxNCxcbiAgICA1MDEsXG5dKTtcblxuLyoqXG4gKiBTZXQgb2YgSFRUUCBzdGF0dXMgY29kZXMgdGhhdCB0aGUgY2FjaGUgaW1wbGVtZW50YXRpb24gdW5kZXJzdGFuZHMuXG4gKiBOb3RlOiBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHVuZGVyc3RhbmQgcGFydGlhbCByZXNwb25zZXMgKDIwNikuXG4gKiBAdHlwZSB7U2V0PG51bWJlcj59XG4gKi9cbmNvbnN0IHVuZGVyc3Rvb2RTdGF0dXNlcyA9IG5ldyBTZXQoW1xuICAgIDIwMCxcbiAgICAyMDMsXG4gICAgMjA0LFxuICAgIDMwMCxcbiAgICAzMDEsXG4gICAgMzAyLFxuICAgIDMwMyxcbiAgICAzMDcsXG4gICAgMzA4LFxuICAgIDQwNCxcbiAgICA0MDUsXG4gICAgNDEwLFxuICAgIDQxNCxcbiAgICA1MDEsXG5dKTtcblxuLyoqXG4gKiBTZXQgb2YgSFRUUCBlcnJvciBzdGF0dXMgY29kZXMuXG4gKiBAdHlwZSB7U2V0PG51bWJlcj59XG4gKi9cbmNvbnN0IGVycm9yU3RhdHVzQ29kZXMgPSBuZXcgU2V0KFtcbiAgICA1MDAsXG4gICAgNTAyLFxuICAgIDUwMyxcbiAgICA1MDQsXG5dKTtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIGhvcC1ieS1ob3AgaGVhZGVycyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fVxuICovXG5jb25zdCBob3BCeUhvcEhlYWRlcnMgPSB7XG4gICAgZGF0ZTogdHJ1ZSwgLy8gaW5jbHVkZWQsIGJlY2F1c2Ugd2UgYWRkIEFnZSB1cGRhdGUgRGF0ZVxuICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgJ2tlZXAtYWxpdmUnOiB0cnVlLFxuICAgICdwcm94eS1hdXRoZW50aWNhdGUnOiB0cnVlLFxuICAgICdwcm94eS1hdXRob3JpemF0aW9uJzogdHJ1ZSxcbiAgICB0ZTogdHJ1ZSxcbiAgICB0cmFpbGVyOiB0cnVlLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IHRydWUsXG4gICAgdXBncmFkZTogdHJ1ZSxcbn07XG5cbi8qKlxuICogSGVhZGVycyB0aGF0IGFyZSBleGNsdWRlZCBmcm9tIHJldmFsaWRhdGlvbiB1cGRhdGUuXG4gKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj59XG4gKi9cbmNvbnN0IGV4Y2x1ZGVkRnJvbVJldmFsaWRhdGlvblVwZGF0ZSA9IHtcbiAgICAvLyBTaW5jZSB0aGUgb2xkIGJvZHkgaXMgcmV1c2VkLCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY2hhbmdlIHByb3BlcnRpZXMgb2YgdGhlIGJvZHlcbiAgICAnY29udGVudC1sZW5ndGgnOiB0cnVlLFxuICAgICdjb250ZW50LWVuY29kaW5nJzogdHJ1ZSxcbiAgICAndHJhbnNmZXItZW5jb2RpbmcnOiB0cnVlLFxuICAgICdjb250ZW50LXJhbmdlJzogdHJ1ZSxcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSBudW1iZXIgb3IgcmV0dXJucyB6ZXJvIGlmIHRoZSBjb252ZXJzaW9uIGZhaWxzLlxuICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcGFyc2VkIG51bWJlciBvciAwLlxuICovXG5mdW5jdGlvbiB0b051bWJlck9yWmVybyhzKSB7XG4gICAgY29uc3QgbiA9IHBhcnNlSW50KHMsIDEwKTtcbiAgICByZXR1cm4gaXNGaW5pdGUobikgPyBuIDogMDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiByZXNwb25zZSBpcyBhbiBlcnJvciByZXNwb25zZS5cbiAqIEltcGxlbWVudHMgUkZDIDU4NjEgYmVoYXZpb3IuXG4gKiBAcGFyYW0ge0h0dHBSZXNwb25zZXx1bmRlZmluZWR9IHJlc3BvbnNlIC0gVGhlIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIGFuIGVycm9yIG9yIHVuZGVmaW5lZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAvLyBjb25zaWRlciB1bmRlZmluZWQgcmVzcG9uc2UgYXMgZmF1bHR5XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yU3RhdHVzQ29kZXMuaGFzKHJlc3BvbnNlLnN0YXR1cyk7XG59XG5cbi8qKlxuICogUGFyc2VzIGEgQ2FjaGUtQ29udHJvbCBoZWFkZXIgc3RyaW5nIGludG8gYW4gb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtoZWFkZXJdIC0gVGhlIENhY2hlLUNvbnRyb2wgaGVhZGVyIHZhbHVlLlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZ3xib29sZWFuPn0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyBDYWNoZS1Db250cm9sIGRpcmVjdGl2ZXMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ2FjaGVDb250cm9sKGhlYWRlcikge1xuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nfGJvb2xlYW4+fSAqL1xuICAgIGNvbnN0IGNjID0ge307XG4gICAgaWYgKCFoZWFkZXIpIHJldHVybiBjYztcblxuICAgIC8vIFRPRE86IFdoZW4gdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSB2YWx1ZSBwcmVzZW50IGZvciBhIGdpdmVuIGRpcmVjdGl2ZSAoZS5nLiwgdHdvIEV4cGlyZXMgaGVhZGVyIGZpZWxkcywgbXVsdGlwbGUgQ2FjaGUtQ29udHJvbDogbWF4LWFnZSBkaXJlY3RpdmVzKSxcbiAgICAvLyB0aGUgZGlyZWN0aXZlJ3MgdmFsdWUgaXMgY29uc2lkZXJlZCBpbnZhbGlkLiBDYWNoZXMgYXJlIGVuY291cmFnZWQgdG8gY29uc2lkZXIgcmVzcG9uc2VzIHRoYXQgaGF2ZSBpbnZhbGlkIGZyZXNobmVzcyBpbmZvcm1hdGlvbiB0byBiZSBzdGFsZVxuICAgIGNvbnN0IHBhcnRzID0gaGVhZGVyLnRyaW0oKS5zcGxpdCgvLC8pO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBjb25zdCBbaywgdl0gPSBwYXJ0LnNwbGl0KC89LywgMik7XG4gICAgICAgIGNjW2sudHJpbSgpXSA9IHYgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB2LnRyaW0oKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2M7XG59XG5cbi8qKlxuICogRm9ybWF0cyBhIENhY2hlLUNvbnRyb2wgZGlyZWN0aXZlcyBvYmplY3QgaW50byBhIGhlYWRlciBzdHJpbmcuXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZ3xib29sZWFuPn0gY2MgLSBUaGUgQ2FjaGUtQ29udHJvbCBkaXJlY3RpdmVzLlxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IEEgZm9ybWF0dGVkIENhY2hlLUNvbnRyb2wgaGVhZGVyIHN0cmluZyBvciB1bmRlZmluZWQgaWYgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdENhY2hlQ29udHJvbChjYykge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgayBpbiBjYykge1xuICAgICAgICBjb25zdCB2ID0gY2Nba107XG4gICAgICAgIHBhcnRzLnB1c2godiA9PT0gdHJ1ZSA/IGsgOiBrICsgJz0nICsgdik7XG4gICAgfVxuICAgIGlmICghcGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcsICcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIENhY2hlUG9saWN5IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENhY2hlUG9saWN5IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIEluY29taW5nIGNsaWVudCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7SHR0cFJlc3BvbnNlfSByZXMgLSBSZWNlaXZlZCBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNoYXJlZD10cnVlXSAtIElzIHRoZSBjYWNoZSBzaGFyZWQgKGEgcHVibGljIHByb3h5KT8gYGZhbHNlYCBmb3IgcGVyc29uYWwgYnJvd3NlciBjYWNoZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNhY2hlSGV1cmlzdGljPTAuMV0gLSBGYWxsYmFjayBoZXVyaXN0aWMgKGFnZSBmcmFjdGlvbikgZm9yIGNhY2hlIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbW11dGFibGVNaW5UaW1lVG9MaXZlPTg2NDAwMDAwXSAtIE1pbmltdW0gVFRMIGZvciBpbW11dGFibGUgcmVzcG9uc2VzIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZUNhcmdvQ3VsdD1mYWxzZV0gLSBEZXRlY3Qgbm9uc2Vuc2UgY2FjaGUgaGVhZGVycywgYW5kIG92ZXJyaWRlIHRoZW0uXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRpb25zLl9mcm9tT2JqZWN0XSAtIEludGVybmFsIHBhcmFtZXRlciBmb3IgZGVzZXJpYWxpemF0aW9uLiBEbyBub3QgdXNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICByZXEsXG4gICAgICAgIHJlcyxcbiAgICAgICAge1xuICAgICAgICAgICAgc2hhcmVkLFxuICAgICAgICAgICAgY2FjaGVIZXVyaXN0aWMsXG4gICAgICAgICAgICBpbW11dGFibGVNaW5UaW1lVG9MaXZlLFxuICAgICAgICAgICAgaWdub3JlQ2FyZ29DdWx0LFxuICAgICAgICAgICAgX2Zyb21PYmplY3QsXG4gICAgICAgIH0gPSB7fVxuICAgICkge1xuICAgICAgICBpZiAoX2Zyb21PYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zyb21PYmplY3QoX2Zyb21PYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXMgfHwgIXJlcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVzcG9uc2UgaGVhZGVycyBtaXNzaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMocmVxKTtcblxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gVGltZXN0YW1wIHdoZW4gdGhlIHJlc3BvbnNlIHdhcyByZWNlaXZlZCAqL1xuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWUgPSB0aGlzLm5vdygpO1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IEluZGljYXRlcyBpZiB0aGUgY2FjaGUgaXMgc2hhcmVkICovXG4gICAgICAgIHRoaXMuX2lzU2hhcmVkID0gc2hhcmVkICE9PSBmYWxzZTtcbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSBJbmRpY2F0ZXMgaWYgbGVnYWN5IGNhcmdvIGN1bHQgZGlyZWN0aXZlcyBzaG91bGQgYmUgaWdub3JlZCAqL1xuICAgICAgICB0aGlzLl9pZ25vcmVDYXJnb0N1bHQgPSAhIWlnbm9yZUNhcmdvQ3VsdDtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9IEhldXJpc3RpYyBjYWNoZSBmcmFjdGlvbiAqL1xuICAgICAgICB0aGlzLl9jYWNoZUhldXJpc3RpYyA9XG4gICAgICAgICAgICB1bmRlZmluZWQgIT09IGNhY2hlSGV1cmlzdGljID8gY2FjaGVIZXVyaXN0aWMgOiAwLjE7IC8vIDEwJSBtYXRjaGVzIElFXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBNaW5pbXVtIFRUTCBmb3IgaW1tdXRhYmxlIHJlc3BvbnNlcyBpbiBtcyAqL1xuICAgICAgICB0aGlzLl9pbW11dGFibGVNaW5UdGwgPVxuICAgICAgICAgICAgdW5kZWZpbmVkICE9PSBpbW11dGFibGVNaW5UaW1lVG9MaXZlXG4gICAgICAgICAgICAgICAgPyBpbW11dGFibGVNaW5UaW1lVG9MaXZlXG4gICAgICAgICAgICAgICAgOiAyNCAqIDM2MDAgKiAxMDAwO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBIVFRQIHN0YXR1cyBjb2RlICovXG4gICAgICAgIHRoaXMuX3N0YXR1cyA9ICdzdGF0dXMnIGluIHJlcyA/IHJlcy5zdGF0dXMgOiAyMDA7XG4gICAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gUmVzcG9uc2UgaGVhZGVycyAqL1xuICAgICAgICB0aGlzLl9yZXNIZWFkZXJzID0gcmVzLmhlYWRlcnM7XG4gICAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nfGJvb2xlYW4+fSBQYXJzZWQgQ2FjaGUtQ29udHJvbCBkaXJlY3RpdmVzIGZyb20gcmVzcG9uc2UgKi9cbiAgICAgICAgdGhpcy5fcmVzY2MgPSBwYXJzZUNhY2hlQ29udHJvbChyZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddKTtcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IEhUVFAgbWV0aG9kIChlLmcuLCBHRVQsIFBPU1QpICovXG4gICAgICAgIHRoaXMuX21ldGhvZCA9ICdtZXRob2QnIGluIHJlcSA/IHJlcS5tZXRob2QgOiAnR0VUJztcbiAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9IFJlcXVlc3QgVVJMICovXG4gICAgICAgIHRoaXMuX3VybCA9IHJlcS51cmw7XG4gICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSBIb3N0IGhlYWRlciBmcm9tIHRoZSByZXF1ZXN0ICovXG4gICAgICAgIHRoaXMuX2hvc3QgPSByZXEuaGVhZGVycy5ob3N0O1xuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlcXVlc3QgZG9lcyBub3QgaW5jbHVkZSBhbiBBdXRob3JpemF0aW9uIGhlYWRlciAqL1xuICAgICAgICB0aGlzLl9ub0F1dGhvcml6YXRpb24gPSAhcmVxLmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcbiAgICAgICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fG51bGx9IFJlcXVlc3QgaGVhZGVycyB1c2VkIGZvciBWYXJ5IG1hdGNoaW5nICovXG4gICAgICAgIHRoaXMuX3JlcUhlYWRlcnMgPSByZXMuaGVhZGVycy52YXJ5ID8gcmVxLmhlYWRlcnMgOiBudWxsOyAvLyBEb24ndCBrZWVwIGFsbCByZXF1ZXN0IGhlYWRlcnMgaWYgdGhleSB3b24ndCBiZSB1c2VkXG4gICAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nfGJvb2xlYW4+fSBQYXJzZWQgQ2FjaGUtQ29udHJvbCBkaXJlY3RpdmVzIGZyb20gcmVxdWVzdCAqL1xuICAgICAgICB0aGlzLl9yZXFjYyA9IHBhcnNlQ2FjaGVDb250cm9sKHJlcS5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10pO1xuXG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IGlmIHNvbWVvbmUgdXNlcyBsZWdhY3ksIG5vbi1zdGFuZGFyZCB1bmNlY2Vzc2FyeSBvcHRpb25zIHRoZXkgZG9uJ3QgdW5kZXJzdGFuZCBjYWNoaW5nLFxuICAgICAgICAvLyBzbyB0aGVyZSdzIG5vIHBvaW50IHN0cmljbHkgYWRoZXJpbmcgdG8gdGhlIGJsaW5kbHkgY29weSZwYXN0ZWQgZGlyZWN0aXZlcy5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5faWdub3JlQ2FyZ29DdWx0ICYmXG4gICAgICAgICAgICAncHJlLWNoZWNrJyBpbiB0aGlzLl9yZXNjYyAmJlxuICAgICAgICAgICAgJ3Bvc3QtY2hlY2snIGluIHRoaXMuX3Jlc2NjXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWydwcmUtY2hlY2snXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZXNjY1sncG9zdC1jaGVjayddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWyduby1jYWNoZSddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWyduby1zdG9yZSddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc2NjWydtdXN0LXJldmFsaWRhdGUnXTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXNIZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgJ2NhY2hlLWNvbnRyb2wnOiBmb3JtYXRDYWNoZUNvbnRyb2wodGhpcy5fcmVzY2MpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcmVzSGVhZGVycy5leHBpcmVzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3Jlc0hlYWRlcnMucHJhZ21hO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgQ2FjaGUtQ29udHJvbCBoZWFkZXIgZmllbGQgaXMgbm90IHByZXNlbnQgaW4gYSByZXF1ZXN0LCBjYWNoZXMgTVVTVCBjb25zaWRlciB0aGUgbm8tY2FjaGUgcmVxdWVzdCBwcmFnbWEtZGlyZWN0aXZlXG4gICAgICAgIC8vIGFzIGhhdmluZyB0aGUgc2FtZSBlZmZlY3QgYXMgaWYgXCJDYWNoZS1Db250cm9sOiBuby1jYWNoZVwiIHdlcmUgcHJlc2VudCAoc2VlIFNlY3Rpb24gNS4yLjEpLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddID09IG51bGwgJiZcbiAgICAgICAgICAgIC9uby1jYWNoZS8udGVzdChyZXMuaGVhZGVycy5wcmFnbWEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fcmVzY2NbJ25vLWNhY2hlJ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBtb25rZXktcGF0Y2ggaXQgZm9yIHRlc3RpbmcuXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBub3coKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHJlc3BvbnNlIGlzIHN0b3JhYmxlIGluIGEgY2FjaGUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGBmYWxzZWAgaWYgY2FuIG5ldmVyIGJlIGNhY2hlZC5cbiAgICAgKi9cbiAgICBzdG9yYWJsZSgpIHtcbiAgICAgICAgLy8gVGhlIFwibm8tc3RvcmVcIiByZXF1ZXN0IGRpcmVjdGl2ZSBpbmRpY2F0ZXMgdGhhdCBhIGNhY2hlIE1VU1QgTk9UIHN0b3JlIGFueSBwYXJ0IG9mIGVpdGhlciB0aGlzIHJlcXVlc3Qgb3IgYW55IHJlc3BvbnNlIHRvIGl0LlxuICAgICAgICByZXR1cm4gISEoXG4gICAgICAgICAgICAhdGhpcy5fcmVxY2NbJ25vLXN0b3JlJ10gJiZcbiAgICAgICAgICAgIC8vIEEgY2FjaGUgTVVTVCBOT1Qgc3RvcmUgYSByZXNwb25zZSB0byBhbnkgcmVxdWVzdCwgdW5sZXNzOlxuICAgICAgICAgICAgLy8gVGhlIHJlcXVlc3QgbWV0aG9kIGlzIHVuZGVyc3Rvb2QgYnkgdGhlIGNhY2hlIGFuZCBkZWZpbmVkIGFzIGJlaW5nIGNhY2hlYWJsZSwgYW5kXG4gICAgICAgICAgICAoJ0dFVCcgPT09IHRoaXMuX21ldGhvZCB8fFxuICAgICAgICAgICAgICAgICdIRUFEJyA9PT0gdGhpcy5fbWV0aG9kIHx8XG4gICAgICAgICAgICAgICAgKCdQT1NUJyA9PT0gdGhpcy5fbWV0aG9kICYmIHRoaXMuX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpKSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBzdGF0dXMgY29kZSBpcyB1bmRlcnN0b29kIGJ5IHRoZSBjYWNoZSwgYW5kXG4gICAgICAgICAgICB1bmRlcnN0b29kU3RhdHVzZXMuaGFzKHRoaXMuX3N0YXR1cykgJiZcbiAgICAgICAgICAgIC8vIHRoZSBcIm5vLXN0b3JlXCIgY2FjaGUgZGlyZWN0aXZlIGRvZXMgbm90IGFwcGVhciBpbiByZXF1ZXN0IG9yIHJlc3BvbnNlIGhlYWRlciBmaWVsZHMsIGFuZFxuICAgICAgICAgICAgIXRoaXMuX3Jlc2NjWyduby1zdG9yZSddICYmXG4gICAgICAgICAgICAvLyB0aGUgXCJwcml2YXRlXCIgcmVzcG9uc2UgZGlyZWN0aXZlIGRvZXMgbm90IGFwcGVhciBpbiB0aGUgcmVzcG9uc2UsIGlmIHRoZSBjYWNoZSBpcyBzaGFyZWQsIGFuZFxuICAgICAgICAgICAgKCF0aGlzLl9pc1NoYXJlZCB8fCAhdGhpcy5fcmVzY2MucHJpdmF0ZSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZCBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIHJlcXVlc3QsIGlmIHRoZSBjYWNoZSBpcyBzaGFyZWQsXG4gICAgICAgICAgICAoIXRoaXMuX2lzU2hhcmVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9BdXRob3JpemF0aW9uIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsb3dzU3RvcmluZ0F1dGhlbnRpY2F0ZWQoKSkgJiZcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBlaXRoZXI6XG4gICAgICAgICAgICAvLyBjb250YWlucyBhbiBFeHBpcmVzIGhlYWRlciBmaWVsZCwgb3JcbiAgICAgICAgICAgICh0aGlzLl9yZXNIZWFkZXJzLmV4cGlyZXMgfHxcbiAgICAgICAgICAgICAgICAvLyBjb250YWlucyBhIG1heC1hZ2UgcmVzcG9uc2UgZGlyZWN0aXZlLCBvclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIGEgcy1tYXhhZ2UgcmVzcG9uc2UgZGlyZWN0aXZlIGFuZCB0aGUgY2FjaGUgaXMgc2hhcmVkLCBvclxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5zIGEgcHVibGljIHJlc3BvbnNlIGRpcmVjdGl2ZS5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNjY1snbWF4LWFnZSddIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX2lzU2hhcmVkICYmIHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2NjLnB1YmxpYyB8fFxuICAgICAgICAgICAgICAgIC8vIGhhcyBhIHN0YXR1cyBjb2RlIHRoYXQgaXMgZGVmaW5lZCBhcyBjYWNoZWFibGUgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGVDYWNoZWFibGVCeURlZmF1bHQuaGFzKHRoaXMuX3N0YXR1cykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZXhwaXJhdGlvbiBpcyBleHBsaWNpdGx5IGRlZmluZWQuXG4gICAgICovXG4gICAgX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpIHtcbiAgICAgICAgLy8gNC4yLjEgQ2FsY3VsYXRpbmcgRnJlc2huZXNzIExpZmV0aW1lXG4gICAgICAgIHJldHVybiAhIShcbiAgICAgICAgICAgICh0aGlzLl9pc1NoYXJlZCAmJiB0aGlzLl9yZXNjY1sncy1tYXhhZ2UnXSkgfHxcbiAgICAgICAgICAgIHRoaXMuX3Jlc2NjWydtYXgtYWdlJ10gfHxcbiAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnMuZXhwaXJlc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIGEgcmVxdWVzdFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgaGVhZGVycyBhcmUgbWlzc2luZy5cbiAgICAgKi9cbiAgICBfYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMocmVxKSB7XG4gICAgICAgIGlmICghcmVxIHx8ICFyZXEuaGVhZGVycykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlcXVlc3QgaGVhZGVycyBtaXNzaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHJlcXVlc3QgbWF0Y2hlcyB0aGUgY2FjaGUgYW5kIGNhbiBiZSBzYXRpc2ZpZWQgZnJvbSB0aGUgY2FjaGUgaW1tZWRpYXRlbHksXG4gICAgICogd2l0aG91dCBoYXZpbmcgdG8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgZG9lc24ndCBzdXBwb3J0IGBzdGFsZS13aGlsZS1yZXZhbGlkYXRlYC4gU2VlIGBldmFsdWF0ZVJlcXVlc3QoKWAgZm9yIGEgbW9yZSBjb21wbGV0ZSBzb2x1dGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIFRoZSBuZXcgaW5jb21pbmcgSFRUUCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWBgIGlmIHRoZSBjYWNoZWQgcmVzcG9uc2UgdXNlZCB0byBjb25zdHJ1Y3QgdGhpcyBjYWNoZSBwb2xpY3kgc2F0aXNmaWVzIHRoZSByZXF1ZXN0IHdpdGhvdXQgcmV2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHNhdGlzZmllc1dpdGhvdXRSZXZhbGlkYXRpb24ocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXZhbHVhdGVSZXF1ZXN0KHJlcSk7XG4gICAgICAgIHJldHVybiAhcmVzdWx0LnJldmFsaWRhdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3toZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBzeW5jaHJvbm91czogYm9vbGVhbn18dW5kZWZpbmVkfSByZXZhbGlkYXRpb24gLSBSZXZhbGlkYXRpb24gaW5mb3JtYXRpb24sIGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyB7e3Jlc3BvbnNlOiB7aGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPn0sIHJldmFsaWRhdGlvbjoge2hlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIHN5bmNocm9ub3VzOiBib29sZWFufXx1bmRlZmluZWR9fSBBbiBvYmplY3Qgd2l0aCBhIGNhY2hlZCByZXNwb25zZSBoZWFkZXJzIGFuZCByZXZhbGlkYXRpb24gaW5mby5cbiAgICAgKi9cbiAgICBfZXZhbHVhdGVSZXF1ZXN0SGl0UmVzdWx0KHJldmFsaWRhdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLnJlc3BvbnNlSGVhZGVycygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldmFsaWRhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h0dHBSZXF1ZXN0fSByZXF1ZXN0IC0gbmV3IGluY29taW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzeW5jaHJvbm91cyAtIHdoZXRoZXIgcmV2YWxpZGF0aW9uIG11c3QgYmUgc3luY2hyb25vdXMgKG5vdCBzLXctcikuXG4gICAgICogQHJldHVybnMge3toZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBzeW5jaHJvbm91czogYm9vbGVhbn19IEFuIG9iamVjdCB3aXRoIHJldmFsaWRhdGlvbiBoZWFkZXJzIGFuZCBhIHN5bmNocm9ub3VzIGZsYWcuXG4gICAgICovXG4gICAgX2V2YWx1YXRlUmVxdWVzdFJldmFsaWRhdGlvbihyZXF1ZXN0LCBzeW5jaHJvbm91cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3luY2hyb25vdXMsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLnJldmFsaWRhdGlvbkhlYWRlcnMocmVxdWVzdCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIdHRwUmVxdWVzdH0gcmVxdWVzdCAtIG5ldyBpbmNvbWluZ1xuICAgICAqIEByZXR1cm5zIHt7cmVzcG9uc2U6IHVuZGVmaW5lZCwgcmV2YWxpZGF0aW9uOiB7aGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiwgc3luY2hyb25vdXM6IGJvb2xlYW59fX0gQW4gb2JqZWN0IGluZGljYXRpbmcgbm8gY2FjaGVkIHJlc3BvbnNlIGFuZCByZXZhbGlkYXRpb24gZGV0YWlscy5cbiAgICAgKi9cbiAgICBfZXZhbHVhdGVSZXF1ZXN0TWlzc1Jlc3VsdChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNwb25zZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmV2YWxpZGF0aW9uOiB0aGlzLl9ldmFsdWF0ZVJlcXVlc3RSZXZhbGlkYXRpb24ocmVxdWVzdCwgdHJ1ZSksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiByZXF1ZXN0IG1hdGNoZXMgdGhpcyBjYWNoZSBlbnRyeSwgYW5kIGhvdyB0aGUgY2FjaGUgY2FuIGJlIHVzZWQgdG8gc2F0aXNmeSBpdC4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHtcbiAgICAgKiAgICAgLy8gSWYgZGVmaW5lZCwgeW91IG11c3Qgc2VuZCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlci5cbiAgICAgKiAgICAgcmV2YWxpZGF0aW9uOiB7XG4gICAgICogICAgICAgICBoZWFkZXJzOiB7fSwgLy8gSFRUUCBoZWFkZXJzIHRvIHVzZSB3aGVuIHNlbmRpbmcgdGhlIHJldmFsaWRhdGlvbiByZXNwb25zZVxuICAgICAqICAgICAgICAgLy8gSWYgdHJ1ZSwgeW91IE1VU1Qgd2FpdCBmb3IgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHVzaW5nIHRoZSBjYWNoZVxuICAgICAqICAgICAgICAgLy8gSWYgZmFsc2UsIHRoaXMgaXMgc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZS4gVGhlIGNhY2hlIGlzIHN0YWxlLCBidXQgeW91IGNhbiB1c2UgaXQgd2hpbGUgeW91IHVwZGF0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAgICAgKiAgICAgICAgIHN5bmNocm9ub3VzOiBib29sLFxuICAgICAqICAgICB9LFxuICAgICAqICAgICAvLyBJZiBkZWZpbmVkLCB5b3UgY2FuIHVzZSB0aGlzIGNhY2hlZCByZXNwb25zZS5cbiAgICAgKiAgICAgcmVzcG9uc2U6IHtcbiAgICAgKiAgICAgICAgIGhlYWRlcnM6IHt9LCAvLyBVcGRhdGVkIGNhY2hlZCBIVFRQIGhlYWRlcnMgeW91IG11c3QgdXNlIHdoZW4gcmVzcG9uZGluZyB0byB0aGUgY2xpZW50XG4gICAgICogICAgIH0sXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIG5ldyBpbmNvbWluZyBIVFRQIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7e3Jlc3BvbnNlOiB7aGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPn18dW5kZWZpbmVkLCByZXZhbGlkYXRpb246IHtoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LCBzeW5jaHJvbm91czogYm9vbGVhbn18dW5kZWZpbmVkfX0gQW4gb2JqZWN0IGNvbnRhaW5pbmcga2V5czpcbiAgICAgKiAgIC0gcmV2YWxpZGF0aW9uOiB7IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIHN5bmNocm9ub3VzOiBib29sZWFuIH0gU2V0IGlmIHlvdSBzaG91bGQgc2VuZCB0aGlzIHRvIHRoZSBvcmlnaW4gc2VydmVyXG4gICAgICogICAtIHJlc3BvbnNlOiB7IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfSBTZXQgaWYgeW91IGNhbiByZXNwb25kIHRvIHRoZSBjbGllbnQgd2l0aCB0aGVzZSBjYWNoZWQgaGVhZGVyc1xuICAgICAqL1xuICAgIGV2YWx1YXRlUmVxdWVzdChyZXEpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVxdWVzdEhhc0hlYWRlcnMocmVxKTtcblxuICAgICAgICAvLyBJbiBhbGwgY2lyY3Vtc3RhbmNlcywgYSBjYWNoZSBNVVNUIE5PVCBpZ25vcmUgdGhlIG11c3QtcmV2YWxpZGF0ZSBkaXJlY3RpdmVcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydtdXN0LXJldmFsaWRhdGUnXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlUmVxdWVzdE1pc3NSZXN1bHQocmVxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdE1hdGNoZXMocmVxLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZVJlcXVlc3RNaXNzUmVzdWx0KHJlcSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaGVuIHByZXNlbnRlZCB3aXRoIGEgcmVxdWVzdCwgYSBjYWNoZSBNVVNUIE5PVCByZXVzZSBhIHN0b3JlZCByZXNwb25zZSwgdW5sZXNzOlxuICAgICAgICAvLyB0aGUgcHJlc2VudGVkIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiB0aGUgbm8tY2FjaGUgcHJhZ21hIChTZWN0aW9uIDUuNCksIG5vciB0aGUgbm8tY2FjaGUgY2FjaGUgZGlyZWN0aXZlLFxuICAgICAgICAvLyB1bmxlc3MgdGhlIHN0b3JlZCByZXNwb25zZSBpcyBzdWNjZXNzZnVsbHkgdmFsaWRhdGVkIChTZWN0aW9uIDQuMyksIGFuZFxuICAgICAgICBjb25zdCByZXF1ZXN0Q0MgPSBwYXJzZUNhY2hlQ29udHJvbChyZXEuaGVhZGVyc1snY2FjaGUtY29udHJvbCddKTtcblxuICAgICAgICBpZiAocmVxdWVzdENDWyduby1jYWNoZSddIHx8IC9uby1jYWNoZS8udGVzdChyZXEuaGVhZGVycy5wcmFnbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGVSZXF1ZXN0TWlzc1Jlc3VsdChyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3RDQ1snbWF4LWFnZSddICYmIHRoaXMuYWdlKCkgPiB0b051bWJlck9yWmVybyhyZXF1ZXN0Q0NbJ21heC1hZ2UnXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZVJlcXVlc3RNaXNzUmVzdWx0KHJlcSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWVzdENDWydtaW4tZnJlc2gnXSAmJiB0aGlzLm1heEFnZSgpIC0gdGhpcy5hZ2UoKSA8IHRvTnVtYmVyT3JaZXJvKHJlcXVlc3RDQ1snbWluLWZyZXNoJ10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGVSZXF1ZXN0TWlzc1Jlc3VsdChyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHN0b3JlZCByZXNwb25zZSBpcyBlaXRoZXI6XG4gICAgICAgIC8vIGZyZXNoLCBvciBhbGxvd2VkIHRvIGJlIHNlcnZlZCBzdGFsZVxuICAgICAgICBpZiAodGhpcy5zdGFsZSgpKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHZhbHVlIGlzIHByZXNlbnQsIHRoZW4gdGhlIGNsaWVudCBpcyB3aWxsaW5nIHRvIGFjY2VwdCBhIHJlc3BvbnNlIHRoYXQgaGFzXG4gICAgICAgICAgICAvLyBleGNlZWRlZCBpdHMgZnJlc2huZXNzIGxpZmV0aW1lIGJ5IG5vIG1vcmUgdGhhbiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBzZWNvbmRzXG4gICAgICAgICAgICBjb25zdCBhbGxvd3NTdGFsZVdpdGhvdXRSZXZhbGlkYXRpb24gPSAnbWF4LXN0YWxlJyBpbiByZXF1ZXN0Q0MgJiZcbiAgICAgICAgICAgICAgICAodHJ1ZSA9PT0gcmVxdWVzdENDWydtYXgtc3RhbGUnXSB8fCByZXF1ZXN0Q0NbJ21heC1zdGFsZSddID4gdGhpcy5hZ2UoKSAtIHRoaXMubWF4QWdlKCkpO1xuXG4gICAgICAgICAgICBpZiAoYWxsb3dzU3RhbGVXaXRob3V0UmV2YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlUmVxdWVzdEhpdFJlc3VsdCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy51c2VTdGFsZVdoaWxlUmV2YWxpZGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlUmVxdWVzdEhpdFJlc3VsdCh0aGlzLl9ldmFsdWF0ZVJlcXVlc3RSZXZhbGlkYXRpb24ocmVxLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGVSZXF1ZXN0TWlzc1Jlc3VsdChyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlUmVxdWVzdEhpdFJlc3VsdCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIGNoZWNrIGlmIHRoaXMgaXMgZm9yIHRoZSBzYW1lIGNhY2hlIGVudHJ5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd0hlYWRNZXRob2QgLSBhbGxvdyBhIEhFQUQgbWV0aG9kIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgbWF0Y2hlcy5cbiAgICAgKi9cbiAgICBfcmVxdWVzdE1hdGNoZXMocmVxLCBhbGxvd0hlYWRNZXRob2QpIHtcbiAgICAgICAgLy8gVGhlIHByZXNlbnRlZCBlZmZlY3RpdmUgcmVxdWVzdCBVUkkgYW5kIHRoYXQgb2YgdGhlIHN0b3JlZCByZXNwb25zZSBtYXRjaCwgYW5kXG4gICAgICAgIHJldHVybiAhIShcbiAgICAgICAgICAgICghdGhpcy5fdXJsIHx8IHRoaXMuX3VybCA9PT0gcmVxLnVybCkgJiZcbiAgICAgICAgICAgIHRoaXMuX2hvc3QgPT09IHJlcS5oZWFkZXJzLmhvc3QgJiZcbiAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IG1ldGhvZCBhc3NvY2lhdGVkIHdpdGggdGhlIHN0b3JlZCByZXNwb25zZSBhbGxvd3MgaXQgdG8gYmUgdXNlZCBmb3IgdGhlIHByZXNlbnRlZCByZXF1ZXN0LCBhbmRcbiAgICAgICAgICAgICghcmVxLm1ldGhvZCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9PT0gcmVxLm1ldGhvZCB8fFxuICAgICAgICAgICAgICAgIChhbGxvd0hlYWRNZXRob2QgJiYgJ0hFQUQnID09PSByZXEubWV0aG9kKSkgJiZcbiAgICAgICAgICAgIC8vIHNlbGVjdGluZyBoZWFkZXIgZmllbGRzIG5vbWluYXRlZCBieSB0aGUgc3RvcmVkIHJlc3BvbnNlIChpZiBhbnkpIG1hdGNoIHRob3NlIHByZXNlbnRlZCwgYW5kXG4gICAgICAgICAgICB0aGlzLl92YXJ5TWF0Y2hlcyhyZXEpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHN0b3JpbmcgYXV0aGVudGljYXRlZCByZXNwb25zZXMgaXMgYWxsb3dlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGFsbG93ZWQuXG4gICAgICovXG4gICAgX2FsbG93c1N0b3JpbmdBdXRoZW50aWNhdGVkKCkge1xuICAgICAgICAvLyBmb2xsb3dpbmcgQ2FjaGUtQ29udHJvbCByZXNwb25zZSBkaXJlY3RpdmVzIChTZWN0aW9uIDUuMi4yKSBoYXZlIHN1Y2ggYW4gZWZmZWN0OiBtdXN0LXJldmFsaWRhdGUsIHB1YmxpYywgYW5kIHMtbWF4YWdlLlxuICAgICAgICByZXR1cm4gISEoXG4gICAgICAgICAgICB0aGlzLl9yZXNjY1snbXVzdC1yZXZhbGlkYXRlJ10gfHxcbiAgICAgICAgICAgIHRoaXMuX3Jlc2NjLnB1YmxpYyB8fFxuICAgICAgICAgICAgdGhpcy5fcmVzY2NbJ3MtbWF4YWdlJ11cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgVmFyeSBoZWFkZXIgaW4gdGhlIHJlc3BvbnNlIG1hdGNoZXMgdGhlIG5ldyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcSAtIGluY29taW5nIEhUVFAgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhcnkgaGVhZGVycyBtYXRjaC5cbiAgICAgKi9cbiAgICBfdmFyeU1hdGNoZXMocmVxKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzSGVhZGVycy52YXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgVmFyeSBoZWFkZXIgZmllbGQtdmFsdWUgb2YgXCIqXCIgYWx3YXlzIGZhaWxzIHRvIG1hdGNoXG4gICAgICAgIGlmICh0aGlzLl9yZXNIZWFkZXJzLnZhcnkgPT09ICcqJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fcmVzSGVhZGVycy52YXJ5XG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHJlcS5oZWFkZXJzW25hbWVdICE9PSB0aGlzLl9yZXFIZWFkZXJzW25hbWVdKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGdpdmVuIGhlYWRlcnMgd2l0aG91dCBhbnkgaG9wLWJ5LWhvcCBoZWFkZXJzLlxuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaW5IZWFkZXJzIC0gb2xkIGhlYWRlcnMgZnJvbSB0aGUgY2FjaGVkIHJlc3BvbnNlXG4gICAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IEEgbmV3IGhlYWRlcnMgb2JqZWN0IHdpdGhvdXQgaG9wLWJ5LWhvcCBoZWFkZXJzLlxuICAgICAqL1xuICAgIF9jb3B5V2l0aG91dEhvcEJ5SG9wSGVhZGVycyhpbkhlYWRlcnMpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBpbkhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChob3BCeUhvcEhlYWRlcnNbbmFtZV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgaGVhZGVyc1tuYW1lXSA9IGluSGVhZGVyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICAvLyA5LjEuICBDb25uZWN0aW9uXG4gICAgICAgIGlmIChpbkhlYWRlcnMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gaW5IZWFkZXJzLmNvbm5lY3Rpb24udHJpbSgpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVycy53YXJuaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB3YXJuaW5ncyA9IGhlYWRlcnMud2FybmluZy5zcGxpdCgvLC8pLmZpbHRlcih3YXJuaW5nID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIS9eXFxzKjFbMC05XVswLTldLy50ZXN0KHdhcm5pbmcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXdhcm5pbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzLndhcm5pbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMud2FybmluZyA9IHdhcm5pbmdzLmpvaW4oJywnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycyBhZGp1c3RlZCBmb3Igc2VydmluZyB0aGUgY2FjaGVkIHJlc3BvbnNlLlxuICAgICAqIFJlbW92ZXMgaG9wLWJ5LWhvcCBoZWFkZXJzIGFuZCB1cGRhdGVzIHRoZSBBZ2UgYW5kIERhdGUgaGVhZGVycy5cbiAgICAgKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gVGhlIGFkanVzdGVkIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgICovXG4gICAgcmVzcG9uc2VIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5fY29weVdpdGhvdXRIb3BCeUhvcEhlYWRlcnModGhpcy5fcmVzSGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGFnZSA9IHRoaXMuYWdlKCk7XG5cbiAgICAgICAgLy8gQSBjYWNoZSBTSE9VTEQgZ2VuZXJhdGUgMTEzIHdhcm5pbmcgaWYgaXQgaGV1cmlzdGljYWxseSBjaG9zZSBhIGZyZXNobmVzc1xuICAgICAgICAvLyBsaWZldGltZSBncmVhdGVyIHRoYW4gMjQgaG91cnMgYW5kIHRoZSByZXNwb25zZSdzIGFnZSBpcyBncmVhdGVyIHRoYW4gMjQgaG91cnMuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGFnZSA+IDM2MDAgKiAyNCAmJlxuICAgICAgICAgICAgIXRoaXMuX2hhc0V4cGxpY2l0RXhwaXJhdGlvbigpICYmXG4gICAgICAgICAgICB0aGlzLm1heEFnZSgpID4gMzYwMCAqIDI0XG4gICAgICAgICkge1xuICAgICAgICAgICAgaGVhZGVycy53YXJuaW5nID1cbiAgICAgICAgICAgICAgICAoaGVhZGVycy53YXJuaW5nID8gYCR7aGVhZGVycy53YXJuaW5nfSwgYCA6ICcnKSArXG4gICAgICAgICAgICAgICAgJzExMyAtIFwicmZjNzIzNCA1LjUuNFwiJztcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLmFnZSA9IGAke01hdGgucm91bmQoYWdlKX1gO1xuICAgICAgICBoZWFkZXJzLmRhdGUgPSBuZXcgRGF0ZSh0aGlzLm5vdygpKS50b1VUQ1N0cmluZygpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEYXRlIGhlYWRlciB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvciB0aGUgY3VycmVudCB0aW1lIGlmIGludmFsaWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGltZXN0YW1wIChpbiBtaWxsaXNlY29uZHMpIHJlcHJlc2VudGluZyB0aGUgRGF0ZSBoZWFkZXIgb3IgcmVzcG9uc2UgdGltZS5cbiAgICAgKi9cbiAgICBkYXRlKCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJEYXRlID0gRGF0ZS5wYXJzZSh0aGlzLl9yZXNIZWFkZXJzLmRhdGUpO1xuICAgICAgICBpZiAoaXNGaW5pdGUoc2VydmVyRGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJEYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZVRpbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsdWUgb2YgdGhlIEFnZSBoZWFkZXIsIGluIHNlY29uZHMsIHVwZGF0ZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICogTWF5IGJlIGZyYWN0aW9uYWwuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGFnZSBpbiBzZWNvbmRzLlxuICAgICAqL1xuICAgIGFnZSgpIHtcbiAgICAgICAgbGV0IGFnZSA9IHRoaXMuX2FnZVZhbHVlKCk7XG5cbiAgICAgICAgY29uc3QgcmVzaWRlbnRUaW1lID0gKHRoaXMubm93KCkgLSB0aGlzLl9yZXNwb25zZVRpbWUpIC8gMTAwMDtcbiAgICAgICAgcmV0dXJuIGFnZSArIHJlc2lkZW50VGltZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgQWdlIGhlYWRlciB2YWx1ZSBhcyBhIG51bWJlci5cbiAgICAgKi9cbiAgICBfYWdlVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0b051bWJlck9yWmVybyh0aGlzLl9yZXNIZWFkZXJzLmFnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zc2libHkgb3V0ZGF0ZWQgdmFsdWUgb2YgYXBwbGljYWJsZSBtYXgtYWdlIChvciBoZXVyaXN0aWMgZXF1aXZhbGVudCkgaW4gc2Vjb25kcy5cbiAgICAgKiBUaGlzIGNvdW50cyBzaW5jZSByZXNwb25zZSdzIGBEYXRlYC5cbiAgICAgKlxuICAgICAqIEZvciBhbiB1cC10by1kYXRlIHZhbHVlLCBzZWUgYHRpbWVUb0xpdmUoKWAuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGFnZSAoZnJlc2huZXNzIGxpZmV0aW1lKSBvZiB0aGUgcmVzcG9uc2UgaW4gc2Vjb25kcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbWF4LWFnZSB2YWx1ZSBpbiBzZWNvbmRzLlxuICAgICAqL1xuICAgIG1heEFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0b3JhYmxlKCkgfHwgdGhpcy5fcmVzY2NbJ25vLWNhY2hlJ10pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hhcmVkIHJlc3BvbnNlcyB3aXRoIGNvb2tpZXMgYXJlIGNhY2hlYWJsZSBhY2NvcmRpbmcgdG8gdGhlIFJGQywgYnV0IElNSE8gaXQnZCBiZSB1bndpc2UgdG8gZG8gc28gYnkgZGVmYXVsdFxuICAgICAgICAvLyBzbyB0aGlzIGltcGxlbWVudGF0aW9uIHJlcXVpcmVzIGV4cGxpY2l0IG9wdC1pbiB2aWEgcHVibGljIGhlYWRlclxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9pc1NoYXJlZCAmJlxuICAgICAgICAgICAgKHRoaXMuX3Jlc0hlYWRlcnNbJ3NldC1jb29raWUnXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLl9yZXNjYy5wdWJsaWMgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5fcmVzY2MuaW1tdXRhYmxlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnMudmFyeSA9PT0gJyonKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pc1NoYXJlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydwcm94eS1yZXZhbGlkYXRlJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGEgcmVzcG9uc2UgaW5jbHVkZXMgdGhlIHMtbWF4YWdlIGRpcmVjdGl2ZSwgYSBzaGFyZWQgY2FjaGUgcmVjaXBpZW50IE1VU1QgaWdub3JlIHRoZSBFeHBpcmVzIGZpZWxkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc2NjWydzLW1heGFnZSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgcmVzcG9uc2UgaW5jbHVkZXMgYSBDYWNoZS1Db250cm9sIGZpZWxkIHdpdGggdGhlIG1heC1hZ2UgZGlyZWN0aXZlLCBhIHJlY2lwaWVudCBNVVNUIGlnbm9yZSB0aGUgRXhwaXJlcyBmaWVsZC5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc2NjWydtYXgtYWdlJ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0b051bWJlck9yWmVybyh0aGlzLl9yZXNjY1snbWF4LWFnZSddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaW5UdGwgPSB0aGlzLl9yZXNjYy5pbW11dGFibGUgPyB0aGlzLl9pbW11dGFibGVNaW5UdGwgOiAwO1xuXG4gICAgICAgIGNvbnN0IHNlcnZlckRhdGUgPSB0aGlzLmRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnMuZXhwaXJlcykge1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlcyA9IERhdGUucGFyc2UodGhpcy5fcmVzSGVhZGVycy5leHBpcmVzKTtcbiAgICAgICAgICAgIC8vIEEgY2FjaGUgcmVjaXBpZW50IE1VU1QgaW50ZXJwcmV0IGludmFsaWQgZGF0ZSBmb3JtYXRzLCBlc3BlY2lhbGx5IHRoZSB2YWx1ZSBcIjBcIiwgYXMgcmVwcmVzZW50aW5nIGEgdGltZSBpbiB0aGUgcGFzdCAoaS5lLiwgXCJhbHJlYWR5IGV4cGlyZWRcIikuXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGV4cGlyZXMpIHx8IGV4cGlyZXMgPCBzZXJ2ZXJEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoZGVmYXVsdE1pblR0bCwgKGV4cGlyZXMgLSBzZXJ2ZXJEYXRlKSAvIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdE1vZGlmaWVkID0gRGF0ZS5wYXJzZSh0aGlzLl9yZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGxhc3RNb2RpZmllZCkgJiYgc2VydmVyRGF0ZSA+IGxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE1pblR0bCxcbiAgICAgICAgICAgICAgICAgICAgKChzZXJ2ZXJEYXRlIC0gbGFzdE1vZGlmaWVkKSAvIDEwMDApICogdGhpcy5fY2FjaGVIZXVyaXN0aWNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRNaW5UdGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtYWluaW5nIHRpbWUgdGhpcyBjYWNoZSBlbnRyeSBtYXkgYmUgdXNlZnVsIGZvciwgaW4gKm1pbGxpc2Vjb25kcyouXG4gICAgICogWW91IGNhbiB1c2UgdGhpcyBhcyBhbiBleHBpcmF0aW9uIHRpbWUgZm9yIHlvdXIgY2FjaGUgc3RvcmFnZS5cbiAgICAgKlxuICAgICAqIFByZWZlciB0aGlzIG1ldGhvZCBvdmVyIGBtYXhBZ2UoKWAsIGJlY2F1c2UgaXQgaW5jbHVkZXMgb3RoZXIgZmFjdG9ycyBsaWtlIGBhZ2VgIGFuZCBgc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZWAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGltZS10by1saXZlIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0aW1lVG9MaXZlKCkge1xuICAgICAgICBjb25zdCBhZ2UgPSB0aGlzLm1heEFnZSgpIC0gdGhpcy5hZ2UoKTtcbiAgICAgICAgY29uc3Qgc3RhbGVJZkVycm9yQWdlID0gYWdlICsgdG9OdW1iZXJPclplcm8odGhpcy5fcmVzY2NbJ3N0YWxlLWlmLWVycm9yJ10pO1xuICAgICAgICBjb25zdCBzdGFsZVdoaWxlUmV2YWxpZGF0ZUFnZSA9IGFnZSArIHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc2NjWydzdGFsZS13aGlsZS1yZXZhbGlkYXRlJ10pO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1heCgwLCBhZ2UsIHN0YWxlSWZFcnJvckFnZSwgc3RhbGVXaGlsZVJldmFsaWRhdGVBZ2UpICogMTAwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhpcyBjYWNoZSBlbnRyeSBpcyBwYXN0IGl0cyBleHBpcmF0aW9uIGRhdGUuXG4gICAgICogTm90ZSB0aGF0IHN0YWxlIGNhY2hlIG1heSBiZSB1c2VmdWwgc29tZXRpbWVzLCBzZWUgYGV2YWx1YXRlUmVxdWVzdCgpYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYGZhbHNlYCBkb2Vzbid0IG1lYW4gaXQncyBmcmVzaCBub3IgdXNhYmxlXG4gICAgICovXG4gICAgc3RhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEFnZSgpIDw9IHRoaXMuYWdlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBgc3RhbGUtaWYtZXJyb3JgIGNvbmRpdGlvbiBhbGxvd3MgdXNlIG9mIGEgc3RhbGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgX3VzZVN0YWxlSWZFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4QWdlKCkgKyB0b051bWJlck9yWmVybyh0aGlzLl9yZXNjY1snc3RhbGUtaWYtZXJyb3InXSkgPiB0aGlzLmFnZSgpO1xuICAgIH1cblxuICAgIC8qKiBTZWUgYGV2YWx1YXRlUmVxdWVzdCgpYCBmb3IgYSBtb3JlIGNvbXBsZXRlIHNvbHV0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBgc3RhbGUtd2hpbGUtcmV2YWxpZGF0ZWAgaXMgY3VycmVudGx5IGFsbG93ZWQuXG4gICAgICovXG4gICAgdXNlU3RhbGVXaGlsZVJldmFsaWRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHN3ciA9IHRvTnVtYmVyT3JaZXJvKHRoaXMuX3Jlc2NjWydzdGFsZS13aGlsZS1yZXZhbGlkYXRlJ10pO1xuICAgICAgICByZXR1cm4gc3dyID4gMCAmJiB0aGlzLm1heEFnZSgpICsgc3dyID4gdGhpcy5hZ2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYENhY2hlUG9saWN5YCBpbnN0YW5jZSBmcm9tIGEgc2VyaWFsaXplZCBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIFRoZSBzZXJpYWxpemVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Q2FjaGVQb2xpY3l9IEEgbmV3IENhY2hlUG9saWN5IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXModW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgX2Zyb21PYmplY3Q6IG9iaiB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gb2JqIC0gVGhlIHNlcmlhbGl6ZWQgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbHJlYWR5IGluaXRpYWxpemVkIG9yIGlmIHRoZSBvYmplY3QgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBfZnJvbU9iamVjdChvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZSkgdGhyb3cgRXJyb3IoJ1JlaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgaWYgKCFvYmogfHwgb2JqLnYgIT09IDEpIHRocm93IEVycm9yKCdJbnZhbGlkIHNlcmlhbGl6YXRpb24nKTtcblxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWUgPSBvYmoudDtcbiAgICAgICAgdGhpcy5faXNTaGFyZWQgPSBvYmouc2g7XG4gICAgICAgIHRoaXMuX2NhY2hlSGV1cmlzdGljID0gb2JqLmNoO1xuICAgICAgICB0aGlzLl9pbW11dGFibGVNaW5UdGwgPVxuICAgICAgICAgICAgb2JqLmltbSAhPT0gdW5kZWZpbmVkID8gb2JqLmltbSA6IDI0ICogMzYwMCAqIDEwMDA7XG4gICAgICAgIHRoaXMuX2lnbm9yZUNhcmdvQ3VsdCA9ICEhb2JqLmljYztcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gb2JqLnN0O1xuICAgICAgICB0aGlzLl9yZXNIZWFkZXJzID0gb2JqLnJlc2g7XG4gICAgICAgIHRoaXMuX3Jlc2NjID0gb2JqLnJlc2NjO1xuICAgICAgICB0aGlzLl9tZXRob2QgPSBvYmoubTtcbiAgICAgICAgdGhpcy5fdXJsID0gb2JqLnU7XG4gICAgICAgIHRoaXMuX2hvc3QgPSBvYmouaDtcbiAgICAgICAgdGhpcy5fbm9BdXRob3JpemF0aW9uID0gb2JqLmE7XG4gICAgICAgIHRoaXMuX3JlcUhlYWRlcnMgPSBvYmoucmVxaDtcbiAgICAgICAgdGhpcy5fcmVxY2MgPSBvYmoucmVxY2M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyB0aGUgYENhY2hlUG9saWN5YCBpbnN0YW5jZSBpbnRvIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzZXJpYWxpemVkIG9iamVjdC5cbiAgICAgKi9cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHY6IDEsXG4gICAgICAgICAgICB0OiB0aGlzLl9yZXNwb25zZVRpbWUsXG4gICAgICAgICAgICBzaDogdGhpcy5faXNTaGFyZWQsXG4gICAgICAgICAgICBjaDogdGhpcy5fY2FjaGVIZXVyaXN0aWMsXG4gICAgICAgICAgICBpbW06IHRoaXMuX2ltbXV0YWJsZU1pblR0bCxcbiAgICAgICAgICAgIGljYzogdGhpcy5faWdub3JlQ2FyZ29DdWx0LFxuICAgICAgICAgICAgc3Q6IHRoaXMuX3N0YXR1cyxcbiAgICAgICAgICAgIHJlc2g6IHRoaXMuX3Jlc0hlYWRlcnMsXG4gICAgICAgICAgICByZXNjYzogdGhpcy5fcmVzY2MsXG4gICAgICAgICAgICBtOiB0aGlzLl9tZXRob2QsXG4gICAgICAgICAgICB1OiB0aGlzLl91cmwsXG4gICAgICAgICAgICBoOiB0aGlzLl9ob3N0LFxuICAgICAgICAgICAgYTogdGhpcy5fbm9BdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgcmVxaDogdGhpcy5fcmVxSGVhZGVycyxcbiAgICAgICAgICAgIHJlcWNjOiB0aGlzLl9yZXFjYyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXJzIGZvciBzZW5kaW5nIHRvIHRoZSBvcmlnaW4gc2VydmVyIHRvIHJldmFsaWRhdGUgc3RhbGUgcmVzcG9uc2UuXG4gICAgICogQWxsb3dzIHNlcnZlciB0byByZXR1cm4gMzA0IHRvIGFsbG93IHJldXNlIG9mIHRoZSBwcmV2aW91cyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEhvcCBieSBob3AgaGVhZGVycyBhcmUgYWx3YXlzIHN0cmlwcGVkLlxuICAgICAqIFJldmFsaWRhdGlvbiBoZWFkZXJzIG1heSBiZSBhZGRlZCBvciByZW1vdmVkLCBkZXBlbmRpbmcgb24gcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0ge0h0dHBSZXF1ZXN0fSBpbmNvbWluZ1JlcSAtIFRoZSBpbmNvbWluZyBIVFRQIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IFRoZSBoZWFkZXJzIGZvciB0aGUgcmV2YWxpZGF0aW9uIHJlcXVlc3QuXG4gICAgICovXG4gICAgcmV2YWxpZGF0aW9uSGVhZGVycyhpbmNvbWluZ1JlcSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZXF1ZXN0SGFzSGVhZGVycyhpbmNvbWluZ1JlcSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLl9jb3B5V2l0aG91dEhvcEJ5SG9wSGVhZGVycyhpbmNvbWluZ1JlcS5oZWFkZXJzKTtcblxuICAgICAgICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHVuZGVyc3RhbmQgcmFuZ2UgcmVxdWVzdHNcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbJ2lmLXJhbmdlJ107XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0TWF0Y2hlcyhpbmNvbWluZ1JlcSwgdHJ1ZSkgfHwgIXRoaXMuc3RvcmFibGUoKSkge1xuICAgICAgICAgICAgLy8gcmV2YWxpZGF0aW9uIGFsbG93ZWQgdmlhIEhFQURcbiAgICAgICAgICAgIC8vIG5vdCBmb3IgdGhlIHNhbWUgcmVzb3VyY2UsIG9yIHdhc24ndCBhbGxvd2VkIHRvIGJlIGNhY2hlZCBhbnl3YXlcbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ107XG4gICAgICAgICAgICBkZWxldGUgaGVhZGVyc1snaWYtbW9kaWZpZWQtc2luY2UnXTtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogTVVTVCBzZW5kIHRoYXQgZW50aXR5LXRhZyBpbiBhbnkgY2FjaGUgdmFsaWRhdGlvbiByZXF1ZXN0ICh1c2luZyBJZi1NYXRjaCBvciBJZi1Ob25lLU1hdGNoKSBpZiBhbiBlbnRpdHktdGFnIGhhcyBiZWVuIHByb3ZpZGVkIGJ5IHRoZSBvcmlnaW4gc2VydmVyLiAqL1xuICAgICAgICBpZiAodGhpcy5fcmVzSGVhZGVycy5ldGFnKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ10gPSBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ11cbiAgICAgICAgICAgICAgICA/IGAke2hlYWRlcnNbJ2lmLW5vbmUtbWF0Y2gnXX0sICR7dGhpcy5fcmVzSGVhZGVycy5ldGFnfWBcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3Jlc0hlYWRlcnMuZXRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsaWVudHMgTUFZIGlzc3VlIHNpbXBsZSAobm9uLXN1YnJhbmdlKSBHRVQgcmVxdWVzdHMgd2l0aCBlaXRoZXIgd2VhayB2YWxpZGF0b3JzIG9yIHN0cm9uZyB2YWxpZGF0b3JzLiBDbGllbnRzIE1VU1QgTk9UIHVzZSB3ZWFrIHZhbGlkYXRvcnMgaW4gb3RoZXIgZm9ybXMgb2YgcmVxdWVzdC5cbiAgICAgICAgY29uc3QgZm9yYmlkc1dlYWtWYWxpZGF0b3JzID1cbiAgICAgICAgICAgIGhlYWRlcnNbJ2FjY2VwdC1yYW5nZXMnXSB8fFxuICAgICAgICAgICAgaGVhZGVyc1snaWYtbWF0Y2gnXSB8fFxuICAgICAgICAgICAgaGVhZGVyc1snaWYtdW5tb2RpZmllZC1zaW5jZSddIHx8XG4gICAgICAgICAgICAodGhpcy5fbWV0aG9kICYmIHRoaXMuX21ldGhvZCAhPSAnR0VUJyk7XG5cbiAgICAgICAgLyogU0hPVUxEIHNlbmQgdGhlIExhc3QtTW9kaWZpZWQgdmFsdWUgaW4gbm9uLXN1YnJhbmdlIGNhY2hlIHZhbGlkYXRpb24gcmVxdWVzdHMgKHVzaW5nIElmLU1vZGlmaWVkLVNpbmNlKSBpZiBvbmx5IGEgTGFzdC1Nb2RpZmllZCB2YWx1ZSBoYXMgYmVlbiBwcm92aWRlZCBieSB0aGUgb3JpZ2luIHNlcnZlci5cbiAgICAgICAgTm90ZTogVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCB1bmRlcnN0YW5kIHBhcnRpYWwgcmVzcG9uc2VzICgyMDYpICovXG4gICAgICAgIGlmIChmb3JiaWRzV2Vha1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzWydpZi1tb2RpZmllZC1zaW5jZSddO1xuXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXRhZ3MgPSBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ11cbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KC8sLylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihldGFnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhL15cXHMqV1xcLy8udGVzdChldGFnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFldGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbJ2lmLW5vbmUtbWF0Y2gnXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydpZi1ub25lLW1hdGNoJ10gPSBldGFncy5qb2luKCcsJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSAmJlxuICAgICAgICAgICAgIWhlYWRlcnNbJ2lmLW1vZGlmaWVkLXNpbmNlJ11cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydpZi1tb2RpZmllZC1zaW5jZSddID0gdGhpcy5fcmVzSGVhZGVyc1snbGFzdC1tb2RpZmllZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBuZXcgQ2FjaGVQb2xpY3kgd2l0aCBpbmZvcm1hdGlvbiBjb21iaW5lZCBmcm9tIHRoZSBwcmV2aWV3cyByZXNwb25zZSxcbiAgICAgKiBhbmQgdGhlIG5ldyByZXZhbGlkYXRpb24gcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHtwb2xpY3ksIG1vZGlmaWVkfSB3aGVyZSBtb2RpZmllZCBpcyBhIGJvb2xlYW4gaW5kaWNhdGluZ1xuICAgICAqIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGJvZHkgaGFzIGJlZW4gbW9kaWZpZWQsIGFuZCBvbGQgY2FjaGVkIGJvZHkgY2FuJ3QgYmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SHR0cFJlcXVlc3R9IHJlcXVlc3QgLSBUaGUgbGF0ZXN0IEhUVFAgcmVxdWVzdCBhc2tpbmcgZm9yIHRoZSBjYWNoZWQgZW50cnkuXG4gICAgICogQHBhcmFtIHtIdHRwUmVzcG9uc2V9IHJlc3BvbnNlIC0gVGhlIGxhdGVzdCByZXZhbGlkYXRpb24gSFRUUCByZXNwb25zZSBmcm9tIHRoZSBvcmlnaW4gc2VydmVyLlxuICAgICAqIEByZXR1cm5zIHt7cG9saWN5OiBDYWNoZVBvbGljeSwgbW9kaWZpZWQ6IGJvb2xlYW4sIG1hdGNoZXM6IGJvb2xlYW59fSBUaGUgdXBkYXRlZCBwb2xpY3kgYW5kIG1vZGlmaWNhdGlvbiBzdGF0dXMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSByZXNwb25zZSBoZWFkZXJzIGFyZSBtaXNzaW5nLlxuICAgICAqL1xuICAgIHJldmFsaWRhdGVkUG9saWN5KHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlcXVlc3RIYXNIZWFkZXJzKHJlcXVlc3QpO1xuXG4gICAgICAgIGlmICh0aGlzLl91c2VTdGFsZUlmRXJyb3IoKSAmJiBpc0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcG9saWN5OiB0aGlzLFxuICAgICAgICAgICAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgICAgICAgICAgIG1hdGNoZXM6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzcG9uc2UgfHwgIXJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdSZXNwb25zZSBoZWFkZXJzIG1pc3NpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXNlIGFyZW4ndCBnb2luZyB0byBiZSBzdXBwb3J0ZWQgZXhhY3RseSwgc2luY2Ugb25lIENhY2hlUG9saWN5IG9iamVjdFxuICAgICAgICAvLyBkb2Vzbid0IGtub3cgYWJvdXQgYWxsIHRoZSBvdGhlciBjYWNoZWQgb2JqZWN0cy5cbiAgICAgICAgbGV0IG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gdW5kZWZpbmVkICYmIHJlc3BvbnNlLnN0YXR1cyAhPSAzMDQpIHtcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZXRhZyAmJlxuICAgICAgICAgICAgIS9eXFxzKldcXC8vLnRlc3QocmVzcG9uc2UuaGVhZGVycy5ldGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFwiQWxsIG9mIHRoZSBzdG9yZWQgcmVzcG9uc2VzIHdpdGggdGhlIHNhbWUgc3Ryb25nIHZhbGlkYXRvciBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBzdG9yZWQgcmVzcG9uc2VzIGNvbnRhaW4gdGhlIHNhbWUgc3Ryb25nIHZhbGlkYXRvcixcbiAgICAgICAgICAgIC8vIHRoZW4gdGhlIGNhY2hlIE1VU1QgTk9UIHVzZSB0aGUgbmV3IHJlc3BvbnNlIHRvIHVwZGF0ZSBhbnkgc3RvcmVkIHJlc3BvbnNlcy5cIlxuICAgICAgICAgICAgbWF0Y2hlcyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzSGVhZGVycy5ldGFnICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzSGVhZGVycy5ldGFnLnJlcGxhY2UoL15cXHMqV1xcLy8sICcnKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5ldGFnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3Jlc0hlYWRlcnMuZXRhZyAmJiByZXNwb25zZS5oZWFkZXJzLmV0YWcpIHtcbiAgICAgICAgICAgIC8vIFwiSWYgdGhlIG5ldyByZXNwb25zZSBjb250YWlucyBhIHdlYWsgdmFsaWRhdG9yIGFuZCB0aGF0IHZhbGlkYXRvciBjb3JyZXNwb25kc1xuICAgICAgICAgICAgLy8gdG8gb25lIG9mIHRoZSBjYWNoZSdzIHN0b3JlZCByZXNwb25zZXMsXG4gICAgICAgICAgICAvLyB0aGVuIHRoZSBtb3N0IHJlY2VudCBvZiB0aG9zZSBtYXRjaGluZyBzdG9yZWQgcmVzcG9uc2VzIGlzIHNlbGVjdGVkIGZvciB1cGRhdGUuXCJcbiAgICAgICAgICAgIG1hdGNoZXMgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnMuZXRhZy5yZXBsYWNlKC9eXFxzKldcXC8vLCAnJykgPT09XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5ldGFnLnJlcGxhY2UoL15cXHMqV1xcLy8sICcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9yZXNIZWFkZXJzWydsYXN0LW1vZGlmaWVkJ10pIHtcbiAgICAgICAgICAgIG1hdGNoZXMgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc0hlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSA9PT1cbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzWydsYXN0LW1vZGlmaWVkJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV3IHJlc3BvbnNlIGRvZXMgbm90IGluY2x1ZGUgYW55IGZvcm0gb2YgdmFsaWRhdG9yIChzdWNoIGFzIGluIHRoZSBjYXNlIHdoZXJlXG4gICAgICAgICAgICAvLyBhIGNsaWVudCBnZW5lcmF0ZXMgYW4gSWYtTW9kaWZpZWQtU2luY2UgcmVxdWVzdCBmcm9tIGEgc291cmNlIG90aGVyIHRoYW4gdGhlIExhc3QtTW9kaWZpZWRcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlIGhlYWRlciBmaWVsZCksIGFuZCB0aGVyZSBpcyBvbmx5IG9uZSBzdG9yZWQgcmVzcG9uc2UsIGFuZCB0aGF0IHN0b3JlZCByZXNwb25zZSBhbHNvXG4gICAgICAgICAgICAvLyBsYWNrcyBhIHZhbGlkYXRvciwgdGhlbiB0aGF0IHN0b3JlZCByZXNwb25zZSBpcyBzZWxlY3RlZCBmb3IgdXBkYXRlLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICF0aGlzLl9yZXNIZWFkZXJzLmV0YWcgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5fcmVzSGVhZGVyc1snbGFzdC1tb2RpZmllZCddICYmXG4gICAgICAgICAgICAgICAgIXJlc3BvbnNlLmhlYWRlcnMuZXRhZyAmJlxuICAgICAgICAgICAgICAgICFyZXNwb25zZS5oZWFkZXJzWydsYXN0LW1vZGlmaWVkJ11cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG1hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3B0aW9uc0NvcHkgPSB7XG4gICAgICAgICAgICBzaGFyZWQ6IHRoaXMuX2lzU2hhcmVkLFxuICAgICAgICAgICAgY2FjaGVIZXVyaXN0aWM6IHRoaXMuX2NhY2hlSGV1cmlzdGljLFxuICAgICAgICAgICAgaW1tdXRhYmxlTWluVGltZVRvTGl2ZTogdGhpcy5faW1tdXRhYmxlTWluVHRsLFxuICAgICAgICAgICAgaWdub3JlQ2FyZ29DdWx0OiB0aGlzLl9pZ25vcmVDYXJnb0N1bHQsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBvbGljeTogbmV3IHRoaXMuY29uc3RydWN0b3IocmVxdWVzdCwgcmVzcG9uc2UsIG9wdGlvbnNDb3B5KSxcbiAgICAgICAgICAgICAgICAvLyBDbGllbnQgcmVjZWl2aW5nIDMwNCB3aXRob3V0IGJvZHksIGV2ZW4gaWYgaXQncyBpbnZhbGlkL21pc21hdGNoZWQgaGFzIG5vIG9wdGlvblxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0byByZXVzZSBhIGNhY2hlZCBib2R5LiBXZSBkb24ndCBoYXZlIGEgZ29vZCB3YXkgdG8gdGVsbCBjbGllbnRzIHRvIGRvXG4gICAgICAgICAgICAgICAgLy8gZXJyb3IgcmVjb3ZlcnkgaW4gc3VjaCBjYXNlLlxuICAgICAgICAgICAgICAgIG1vZGlmaWVkOiByZXNwb25zZS5zdGF0dXMgIT0gMzA0LFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSBvdGhlciBoZWFkZXIgZmllbGRzIHByb3ZpZGVkIGluIHRoZSAzMDQgKE5vdCBNb2RpZmllZCkgcmVzcG9uc2UgdG8gcmVwbGFjZSBhbGwgaW5zdGFuY2VzXG4gICAgICAgIC8vIG9mIHRoZSBjb3JyZXNwb25kaW5nIGhlYWRlciBmaWVsZHMgaW4gdGhlIHN0b3JlZCByZXNwb25zZS5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdGhpcy5fcmVzSGVhZGVycykge1xuICAgICAgICAgICAgaGVhZGVyc1trXSA9XG4gICAgICAgICAgICAgICAgayBpbiByZXNwb25zZS5oZWFkZXJzICYmICFleGNsdWRlZEZyb21SZXZhbGlkYXRpb25VcGRhdGVba11cbiAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZS5oZWFkZXJzW2tdXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fcmVzSGVhZGVyc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1Jlc3BvbnNlID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzcG9uc2UsIHtcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5fc3RhdHVzLFxuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLl9tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvbGljeTogbmV3IHRoaXMuY29uc3RydWN0b3IocmVxdWVzdCwgbmV3UmVzcG9uc2UsIG9wdGlvbnNDb3B5KSxcbiAgICAgICAgICAgIG1vZGlmaWVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1hdGNoZXM6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJzdGF0dXNDb2RlQ2FjaGVhYmxlQnlEZWZhdWx0IiwiU2V0IiwidW5kZXJzdG9vZFN0YXR1c2VzIiwiZXJyb3JTdGF0dXNDb2RlcyIsImhvcEJ5SG9wSGVhZGVycyIsImRhdGUiLCJjb25uZWN0aW9uIiwidGUiLCJ0cmFpbGVyIiwidXBncmFkZSIsImV4Y2x1ZGVkRnJvbVJldmFsaWRhdGlvblVwZGF0ZSIsInRvTnVtYmVyT3JaZXJvIiwicyIsIm4iLCJwYXJzZUludCIsImlzRmluaXRlIiwiaXNFcnJvclJlc3BvbnNlIiwicmVzcG9uc2UiLCJoYXMiLCJzdGF0dXMiLCJwYXJzZUNhY2hlQ29udHJvbCIsImhlYWRlciIsImNjIiwicGFydHMiLCJ0cmltIiwic3BsaXQiLCJwYXJ0IiwiayIsInYiLCJ1bmRlZmluZWQiLCJyZXBsYWNlIiwiZm9ybWF0Q2FjaGVDb250cm9sIiwicHVzaCIsImxlbmd0aCIsImpvaW4iLCJtb2R1bGUiLCJleHBvcnRzIiwiQ2FjaGVQb2xpY3kiLCJjb25zdHJ1Y3RvciIsInJlcSIsInJlcyIsInNoYXJlZCIsImNhY2hlSGV1cmlzdGljIiwiaW1tdXRhYmxlTWluVGltZVRvTGl2ZSIsImlnbm9yZUNhcmdvQ3VsdCIsIl9mcm9tT2JqZWN0IiwiaGVhZGVycyIsIkVycm9yIiwiX2Fzc2VydFJlcXVlc3RIYXNIZWFkZXJzIiwiX3Jlc3BvbnNlVGltZSIsIm5vdyIsIl9pc1NoYXJlZCIsIl9pZ25vcmVDYXJnb0N1bHQiLCJfY2FjaGVIZXVyaXN0aWMiLCJfaW1tdXRhYmxlTWluVHRsIiwiX3N0YXR1cyIsIl9yZXNIZWFkZXJzIiwiX3Jlc2NjIiwiX21ldGhvZCIsIm1ldGhvZCIsIl91cmwiLCJ1cmwiLCJfaG9zdCIsImhvc3QiLCJfbm9BdXRob3JpemF0aW9uIiwiYXV0aG9yaXphdGlvbiIsIl9yZXFIZWFkZXJzIiwidmFyeSIsIl9yZXFjYyIsIk9iamVjdCIsImFzc2lnbiIsImV4cGlyZXMiLCJwcmFnbWEiLCJ0ZXN0IiwiRGF0ZSIsInN0b3JhYmxlIiwiX2hhc0V4cGxpY2l0RXhwaXJhdGlvbiIsInByaXZhdGUiLCJfYWxsb3dzU3RvcmluZ0F1dGhlbnRpY2F0ZWQiLCJwdWJsaWMiLCJzYXRpc2ZpZXNXaXRob3V0UmV2YWxpZGF0aW9uIiwicmVzdWx0IiwiZXZhbHVhdGVSZXF1ZXN0IiwicmV2YWxpZGF0aW9uIiwiX2V2YWx1YXRlUmVxdWVzdEhpdFJlc3VsdCIsInJlc3BvbnNlSGVhZGVycyIsIl9ldmFsdWF0ZVJlcXVlc3RSZXZhbGlkYXRpb24iLCJyZXF1ZXN0Iiwic3luY2hyb25vdXMiLCJyZXZhbGlkYXRpb25IZWFkZXJzIiwiX2V2YWx1YXRlUmVxdWVzdE1pc3NSZXN1bHQiLCJfcmVxdWVzdE1hdGNoZXMiLCJyZXF1ZXN0Q0MiLCJhZ2UiLCJtYXhBZ2UiLCJzdGFsZSIsImFsbG93c1N0YWxlV2l0aG91dFJldmFsaWRhdGlvbiIsInVzZVN0YWxlV2hpbGVSZXZhbGlkYXRlIiwiYWxsb3dIZWFkTWV0aG9kIiwiX3ZhcnlNYXRjaGVzIiwiZmllbGRzIiwidG9Mb3dlckNhc2UiLCJuYW1lIiwiX2NvcHlXaXRob3V0SG9wQnlIb3BIZWFkZXJzIiwiaW5IZWFkZXJzIiwidG9rZW5zIiwid2FybmluZyIsIndhcm5pbmdzIiwiZmlsdGVyIiwiTWF0aCIsInJvdW5kIiwidG9VVENTdHJpbmciLCJzZXJ2ZXJEYXRlIiwicGFyc2UiLCJfYWdlVmFsdWUiLCJyZXNpZGVudFRpbWUiLCJpbW11dGFibGUiLCJkZWZhdWx0TWluVHRsIiwiTnVtYmVyIiwiaXNOYU4iLCJtYXgiLCJsYXN0TW9kaWZpZWQiLCJ0aW1lVG9MaXZlIiwic3RhbGVJZkVycm9yQWdlIiwic3RhbGVXaGlsZVJldmFsaWRhdGVBZ2UiLCJfdXNlU3RhbGVJZkVycm9yIiwic3dyIiwiZnJvbU9iamVjdCIsIm9iaiIsInQiLCJzaCIsImNoIiwiaW1tIiwiaWNjIiwic3QiLCJyZXNoIiwicmVzY2MiLCJtIiwidSIsImgiLCJhIiwicmVxaCIsInJlcWNjIiwidG9PYmplY3QiLCJpbmNvbWluZ1JlcSIsImV0YWciLCJmb3JiaWRzV2Vha1ZhbGlkYXRvcnMiLCJldGFncyIsInJldmFsaWRhdGVkUG9saWN5IiwicG9saWN5IiwibW9kaWZpZWQiLCJtYXRjaGVzIiwib3B0aW9uc0NvcHkiLCJuZXdSZXNwb25zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/http-cache-semantics/index.js\n");

/***/ })

};
;